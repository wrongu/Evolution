<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0) on Sun Feb 04 22:57:22 CET 2007 -->
<TITLE>
FSound (LWJGL API)
</TITLE>

<META NAME="date" CONTENT="2007-02-04">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="FSound (LWJGL API)";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/FSound.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/lwjgl/fmod3/FMusicModule.html" title="class in org.lwjgl.fmod3"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/lwjgl/fmod3/FSound.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="FSound.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.lwjgl.fmod3</FONT>
<BR>
Class FSound</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>org.lwjgl.fmod3.FSound</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>FSound</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
<br>
<P>

<P>
<DL>
<DT><B>Version:</B></DT>
  <DD>$Revision: 2567 $
 $Id: FSound.java 2567 2006-08-31 16:40:53 +0000 (to, 31 aug 2006) matzon $</DD>
<DT><B>Author:</B></DT>
  <DD>Brian Matzon <brian@matzon.dk></DD>
</DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_16BITS">FSOUND_16BITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For 16 bit samples.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_2D">FSOUND_2D</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tells software (not hardware) based sample not to be included in 3d processing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_8BITS">FSOUND_8BITS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For 8 bit samples.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_ALL">FSOUND_ALL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_CAPS_EAX2">FSOUND_CAPS_EAX2</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This driver supports EAX2 reverb</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_CAPS_EAX3">FSOUND_CAPS_EAX3</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This driver supports EAX3 reverb</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_CAPS_HARDWARE">FSOUND_CAPS_HARDWARE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This driver supports hardware accelerated 3d sound.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_CD_PLAYCONTINUOUS">FSOUND_CD_PLAYCONTINUOUS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_CD_PLAYLOOPED">FSOUND_CD_PLAYLOOPED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_CD_PLAYONCE">FSOUND_CD_PLAYONCE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_CD_PLAYRANDOM">FSOUND_CD_PLAYRANDOM</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DELTA">FSOUND_DELTA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For user created source data stored as delta values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_DEFAULTPRIORITY_CLEARUNIT">FSOUND_DSP_DEFAULTPRIORITY_CLEARUNIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DSP CLEAR unit - done first</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_DEFAULTPRIORITY_CLIPANDCOPYUNIT">FSOUND_DSP_DEFAULTPRIORITY_CLIPANDCOPYUNIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DSP CLIP AND COPY unit - last</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_DEFAULTPRIORITY_FFTUNIT">FSOUND_DSP_DEFAULTPRIORITY_FFTUNIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This reads data for FSOUND_DSP_GetSpectrum, so it comes after user units</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_DEFAULTPRIORITY_MUSICUNIT">FSOUND_DSP_DEFAULTPRIORITY_MUSICUNIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DSP MUSIC unit - done third</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_DEFAULTPRIORITY_SFXUNIT">FSOUND_DSP_DEFAULTPRIORITY_SFXUNIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DSP SFX unit - done second</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_DEFAULTPRIORITY_USER">FSOUND_DSP_DEFAULTPRIORITY_USER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;User priority, use this as reference</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_ENABLEFX">FSOUND_ENABLEFX</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allows DX8 FX to be played back on a sound.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FORCEMONO">FSOUND_FORCEMONO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For forcing stereo streams and samples to be mono - needed if using FSOUND_HW3D and stereo data - incurs a small speed hit for streams</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FORMAT_MPEG">FSOUND_FORMAT_MPEG</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FORMAT_OGGVORBIS">FSOUND_FORMAT_OGGVORBIS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FREE">FSOUND_FREE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_CHORUS">FSOUND_FX_CHORUS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_COMPRESSOR">FSOUND_FX_COMPRESSOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_DISTORTION">FSOUND_FX_DISTORTION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_ECHO">FSOUND_FX_ECHO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_FLANGER">FSOUND_FX_FLANGER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_GARGLE">FSOUND_FX_GARGLE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_I3DL2REVERB">FSOUND_FX_I3DL2REVERB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_MAX">FSOUND_FX_MAX</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_PARAMEQ">FSOUND_FX_PARAMEQ</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_WAVES_REVERB">FSOUND_FX_WAVES_REVERB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GCADPCM">FSOUND_GCADPCM</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For Gamecube only - Contents are compressed as Gamecube DSP-ADPCM format</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_HW2D">FSOUND_HW2D</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2D hardware sounds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_HW3D">FSOUND_HW3D</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Attempts to make samples use 3d hardware acceleration.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_IGNORETAGS">FSOUND_IGNORETAGS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Skips id3v2 etc tag checks when opening a stream, to reduce seek/read overhead when opening files (helps with CD performance)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_IMAADPCM">FSOUND_IMAADPCM</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Contents are stored compressed as IMA ADPCM</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_INIT_ACCURATEVULEVELS">FSOUND_INIT_ACCURATEVULEVELS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This latency adjusts FSOUND_GetCurrentLevels, but incurs a small cpu and memory hit</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_INIT_DONTLATENCYADJUST">FSOUND_INIT_DONTLATENCYADJUST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Callbacks are not latency adjusted, and are called at mix time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_INIT_DSOUND_DEFERRED">FSOUND_INIT_DSOUND_DEFERRED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Win32 only - For DirectSound output.  3D commands are batched together and executed at FSOUND_Update.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_INIT_DSOUND_HRTF_FULL">FSOUND_INIT_DSOUND_HRTF_FULL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Win32 only - For DirectSound output.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_INIT_DSOUND_HRTF_LIGHT">FSOUND_INIT_DSOUND_HRTF_LIGHT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Win32 only - For DirectSound output.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_INIT_ENABLESYSTEMCHANNELFX">FSOUND_INIT_ENABLESYSTEMCHANNELFX</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Win32 only - For DirectSound output - Allows FSOUND_FX api to be used on global software mixer output!</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_INIT_GC_INITLIBS">FSOUND_INIT_GC_INITLIBS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GC only    - Initializes GC audio libraries</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_INIT_GLOBALFOCUS">FSOUND_INIT_GLOBALFOCUS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Win32 only - For DirectSound output - sound is not muted when window is out of focus.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_INIT_PS2_DISABLECORE0REVERB">FSOUND_INIT_PS2_DISABLECORE0REVERB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS2 only   - Disable reverb on CORE 0 to regain SRAM</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_INIT_PS2_DISABLECORE1REVERB">FSOUND_INIT_PS2_DISABLECORE1REVERB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS2 only   - Disable reverb on CORE 1 to regain SRAM</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_INIT_PS2_SWAPDMACORES">FSOUND_INIT_PS2_SWAPDMACORES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS2 only   - By default FMOD uses DMA CH0 for mixing, CH1 for uploads, this flag swaps them around</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_INIT_PS2_USEVOLUMERAMPING">FSOUND_INIT_PS2_USEVOLUMERAMPING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PS2 only   - Turns on volume ramping system to remove hardware clicks.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_INIT_STREAM_FROM_MAIN_THREAD">FSOUND_INIT_STREAM_FROM_MAIN_THREAD</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Turns off fmod streamer thread, and makes streaming update from FSOUND_Update called by the user</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_INIT_USEDEFAULTMIDISYNTH">FSOUND_INIT_USEDEFAULTMIDISYNTH</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Win32 only - Causes MIDI playback to force software decoding.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_IT214">FSOUND_IT214</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For user created source data stored using IT214 compression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_IT215">FSOUND_IT215</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For user created source data stored using IT215 compression.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_LOADMEMORY">FSOUND_LOADMEMORY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"name" will be interpreted as a pointer to data for streaming and samples.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_LOADMEMORYIOP">FSOUND_LOADMEMORYIOP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For PS2 only - "name" will be interpreted as a pointer to data for streaming and samples.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_LOADRAW">FSOUND_LOADRAW</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Will ignore file format and treat as raw pcm.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_LOOP_BIDI">FSOUND_LOOP_BIDI</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For bidirectional looping samples.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_LOOP_NORMAL">FSOUND_LOOP_NORMAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For forward looping samples.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_LOOP_OFF">FSOUND_LOOP_OFF</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For non looping samples.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_MIXER_AUTODETECT">FSOUND_MIXER_AUTODETECT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CE/PS2/GC Only - Non interpolating/low quality mixer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_MIXER_BLENDMODE">FSOUND_MIXER_BLENDMODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed / obsolete.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_MIXER_MAX">FSOUND_MIXER_MAX</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_MIXER_MMXP5">FSOUND_MIXER_MMXP5</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed / obsolete.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_MIXER_MMXP6">FSOUND_MIXER_MMXP6</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removed / obsolete.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_MIXER_MONO">FSOUND_MIXER_MONO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CE/PS2/GC only - MONO non interpolating/low quality mixer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_MIXER_QUALITY_AUTODETECT">FSOUND_MIXER_QUALITY_AUTODETECT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;All platforms - Autodetect the fastest quality mixer based on your cpu.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_MIXER_QUALITY_FPU">FSOUND_MIXER_QUALITY_FPU</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Win32/Linux only - Interpolating/volume ramping FPU mixer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_MIXER_QUALITY_MMXP5">FSOUND_MIXER_QUALITY_MMXP5</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Win32/Linux only - Interpolating/volume ramping P5 MMX mixer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_MIXER_QUALITY_MMXP6">FSOUND_MIXER_QUALITY_MMXP6</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Win32/Linux only - Interpolating/volume ramping ppro+ MMX mixer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_MIXER_QUALITY_MONO">FSOUND_MIXER_QUALITY_MONO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CE/PS2/GC only - MONO Interpolating mixer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_MONO">FSOUND_MONO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For mono samples.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_MPEGACCURATE">FSOUND_MPEGACCURATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For FSOUND_Stream_Open - for accurate FSOUND_Stream_GetLengthMs/FSOUND_Stream_SetTime.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_MPEGHALFRATE">FSOUND_MPEGHALFRATE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For FMODCE only - decodes mpeg streams using a lower quality decode, but faster execution</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_MULTICHANNEL">FSOUND_MULTICHANNEL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For PS2 and Gamecube only - Contents are interleaved into a multi-channel (more than stereo) format</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_NONBLOCKING">FSOUND_NONBLOCKING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For FSOUND_Stream_Open/FMUSIC_LoadSong - Causes stream or music to open in the background and not block the foreground app.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_NORMAL">FSOUND_NORMAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_OUTPUT_A3D">FSOUND_OUTPUT_A3D</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A3D driver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_OUTPUT_ALSA">FSOUND_OUTPUT_ALSA</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux Alsa driver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_OUTPUT_ASIO">FSOUND_OUTPUT_ASIO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Low latency ASIO driver</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_OUTPUT_DSOUND">FSOUND_OUTPUT_DSOUND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DirectSound driver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_OUTPUT_ESD">FSOUND_OUTPUT_ESD</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux/Unix ESD (Enlightment Sound Daemon) driver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_OUTPUT_GC">FSOUND_OUTPUT_GC</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gamecube driver</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_OUTPUT_MAC">FSOUND_OUTPUT_MAC</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mac SoundMager driver</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_OUTPUT_NOSOUND">FSOUND_OUTPUT_NOSOUND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NoSound driver, all calls to this succeed but do nothing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_OUTPUT_NOSOUND_NONREALTIME">FSOUND_OUTPUT_NOSOUND_NONREALTIME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is the same As nosound, but the sound generation is driven by FSOUND_Update</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_OUTPUT_OSS">FSOUND_OUTPUT_OSS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux/Unix OSS (Open Sound System) driver, i.e. the kernel sound drivers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_OUTPUT_PS2">FSOUND_OUTPUT_PS2</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PlayStation 2 driver</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_OUTPUT_WINMM">FSOUND_OUTPUT_WINMM</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Windows Multimedia driver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_OUTPUT_XBOX">FSOUND_OUTPUT_XBOX</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Xbox driver</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_PROTOCOL_HTTP">FSOUND_PROTOCOL_HTTP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_PROTOCOL_ICECAST">FSOUND_PROTOCOL_ICECAST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_PROTOCOL_SHOUTCAST">FSOUND_PROTOCOL_SHOUTCAST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_REVERB_FLAGS_CORE0">FSOUND_REVERB_FLAGS_CORE0</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_REVERB_FLAGS_CORE1">FSOUND_REVERB_FLAGS_CORE1</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_REVERB_FLAGS_DECAYHFLIMIT">FSOUND_REVERB_FLAGS_DECAYHFLIMIT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_REVERB_FLAGS_DECAYTIMESCALE">FSOUND_REVERB_FLAGS_DECAYTIMESCALE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_REVERB_FLAGS_DEFAULT">FSOUND_REVERB_FLAGS_DEFAULT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_REVERB_FLAGS_ECHOTIMESCALE">FSOUND_REVERB_FLAGS_ECHOTIMESCALE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_REVERB_FLAGS_MODULATIONTIMESCALE">FSOUND_REVERB_FLAGS_MODULATIONTIMESCALE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_REVERB_FLAGS_REFLECTIONSDELAYSCALE">FSOUND_REVERB_FLAGS_REFLECTIONSDELAYSCALE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_REVERB_FLAGS_REFLECTIONSSCALE">FSOUND_REVERB_FLAGS_REFLECTIONSSCALE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_REVERB_FLAGS_REVERBDELAYSCALE">FSOUND_REVERB_FLAGS_REVERBDELAYSCALE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_REVERB_FLAGS_REVERBSCALE">FSOUND_REVERB_FLAGS_REVERBSCALE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SIGNED">FSOUND_SIGNED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For user created source data containing signed data.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SPEAKERMODE_DOLBYDIGITAL">FSOUND_SPEAKERMODE_DOLBYDIGITAL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dolby Digital Output (XBOX or PC only).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SPEAKERMODE_DTS">FSOUND_SPEAKERMODE_DTS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DTS output (XBOX only).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SPEAKERMODE_HEADPHONES">FSOUND_SPEAKERMODE_HEADPHONES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The speakers are headphones.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SPEAKERMODE_MONO">FSOUND_SPEAKERMODE_MONO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The speakers are monaural.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SPEAKERMODE_PROLOGIC2">FSOUND_SPEAKERMODE_PROLOGIC2</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dolby Prologic 2.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SPEAKERMODE_PROLOGIC2_INTERIOR">FSOUND_SPEAKERMODE_PROLOGIC2_INTERIOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SPEAKERMODE_QUAD">FSOUND_SPEAKERMODE_QUAD</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The speakers are quadraphonic.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SPEAKERMODE_STEREO">FSOUND_SPEAKERMODE_STEREO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The speakers are stereo (default value).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SPEAKERMODE_SURROUND">FSOUND_SPEAKERMODE_SURROUND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The speakers are surround sound.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_STEREO">FSOUND_STEREO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For stereo samples.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_STEREOPAN">FSOUND_STEREOPAN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_STREAM_NET">FSOUND_STREAM_NET</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specifies an internet stream</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_STREAM_NET_BUFFERING">FSOUND_STREAM_NET_BUFFERING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stream is buffering data</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_STREAM_NET_CONNECTING">FSOUND_STREAM_NET_CONNECTING</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stream is connecting to remote host</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_STREAM_NET_ERROR">FSOUND_STREAM_NET_ERROR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stream has suffered a fatal error</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_STREAM_NET_NOTCONNECTED">FSOUND_STREAM_NET_NOTCONNECTED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stream hasn't connected yet</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_STREAM_NET_READY">FSOUND_STREAM_NET_READY</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stream is ready to play</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_STREAMABLE">FSOUND_STREAMABLE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For a streamimg sound where you feed the data to it.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SYSTEMCHANNEL">FSOUND_SYSTEMCHANNEL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SYSTEMSAMPLE">FSOUND_SYSTEMSAMPLE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_TAGFIELD_ASF">FSOUND_TAGFIELD_ASF</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An Advanced Streaming Format header line</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_TAGFIELD_ICECAST">FSOUND_TAGFIELD_ICECAST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An Icecast header line</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_TAGFIELD_ID3V1">FSOUND_TAGFIELD_ID3V1</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Part of an ID3v1 tag</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_TAGFIELD_ID3V2">FSOUND_TAGFIELD_ID3V2</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;An ID3v2 frame</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_TAGFIELD_SHOUTCAST">FSOUND_TAGFIELD_SHOUTCAST</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A SHOUTcast header line</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_TAGFIELD_VORBISCOMMENT">FSOUND_TAGFIELD_VORBISCOMMENT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A vorbis comment</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_UNMANAGED">FSOUND_UNMANAGED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_UNSIGNED">FSOUND_UNSIGNED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For user created source data containing unsigned samples.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_USECORE0">FSOUND_USECORE0</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For PS2 only - Sample/Stream is forced to use hardware voices 00-23</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_USECORE1">FSOUND_USECORE1</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For PS2 only - Sample/Stream is forced to use hardware voices 24-47</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_VAG">FSOUND_VAG</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For PS2 only - Contents are compressed as Sony VAG format</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSound()">FSound</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_3D_GetAttributes(int, java.nio.FloatBuffer, java.nio.FloatBuffer)">FSOUND_3D_GetAttributes</A></B>(int&nbsp;channel,
                        java.nio.FloatBuffer&nbsp;pos,
                        java.nio.FloatBuffer&nbsp;vel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
 <b>Remarks</b>
 A 'distance unit' is specified by FSOUND_3D_SetDistanceFactor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_3D_GetMinMaxDistance(int, java.nio.FloatBuffer)">FSOUND_3D_GetMinMaxDistance</A></B>(int&nbsp;channel,
                            java.nio.FloatBuffer&nbsp;minmax)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current min and max distance for a channel</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_3D_Listener_GetAttributes(java.nio.FloatBuffer, java.nio.FloatBuffer, java.nio.FloatBuffer, java.nio.FloatBuffer, java.nio.FloatBuffer, java.nio.FloatBuffer, java.nio.FloatBuffer, java.nio.FloatBuffer)">FSOUND_3D_Listener_GetAttributes</A></B>(java.nio.FloatBuffer&nbsp;pos,
                                 java.nio.FloatBuffer&nbsp;vel,
                                 java.nio.FloatBuffer&nbsp;fx,
                                 java.nio.FloatBuffer&nbsp;fy,
                                 java.nio.FloatBuffer&nbsp;fz,
                                 java.nio.FloatBuffer&nbsp;tx,
                                 java.nio.FloatBuffer&nbsp;ty,
                                 java.nio.FloatBuffer&nbsp;tz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This retreives the position, velocity and orientation of a 3d sound listener
 
 <b>Remarks</b>
 FSOUND treats +X as right, +Y as up, and +Z as forwards.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_3D_Listener_SetAttributes(java.nio.FloatBuffer, java.nio.FloatBuffer, float, float, float, float, float, float)">FSOUND_3D_Listener_SetAttributes</A></B>(java.nio.FloatBuffer&nbsp;pos,
                                 java.nio.FloatBuffer&nbsp;vel,
                                 float&nbsp;fx,
                                 float&nbsp;fy,
                                 float&nbsp;fz,
                                 float&nbsp;tx,
                                 float&nbsp;ty,
                                 float&nbsp;tz)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This updates the position, velocity and orientation of a 3d sound listener
 
 <b>Remarks</b>
 FSOUND treats +X as right, +Y as up, and +Z as forwards.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_3D_Listener_SetCurrent(int, int)">FSOUND_3D_Listener_SetCurrent</A></B>(int&nbsp;current,
                              int&nbsp;numlisteners)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current listener number and number of listeners, if the user wants to simulate multiple listeners at once.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_3D_SetAttributes(int, java.nio.FloatBuffer, java.nio.FloatBuffer)">FSOUND_3D_SetAttributes</A></B>(int&nbsp;channel,
                        java.nio.FloatBuffer&nbsp;pos,
                        java.nio.FloatBuffer&nbsp;vel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This updates the position and velocity of a 3d sound playing on a channel
 
 <b>Remarks</b>
 FSOUND treats +X as right, +Y as up, and +Z as forwards.
 ---------
 A 'distance unit' is specified by FSOUND_3D_SetDistanceFactor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_3D_SetDistanceFactor(float)">FSOUND_3D_SetDistanceFactor</A></B>(float&nbsp;scale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets FMOD's 3d engine relative distance factor, compared to 1.0 meters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_3D_SetDopplerFactor(float)">FSOUND_3D_SetDopplerFactor</A></B>(float&nbsp;scale)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the doppler shift scale factor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_3D_SetMinMaxDistance(int, float, float)">FSOUND_3D_SetMinMaxDistance</A></B>(int&nbsp;channel,
                            float&nbsp;min,
                            float&nbsp;max)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the minimum and maximum audible distance for a channel.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_3D_SetRolloffFactor(float)">FSOUND_3D_SetRolloffFactor</A></B>(float&nbsp;rolloff)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the global attenuation rolloff factor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_CD_GetNumTracks(char)">FSOUND_CD_GetNumTracks</A></B>(char&nbsp;drive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of tracks on the currently inserted CD</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_CD_GetPaused(char)">FSOUND_CD_GetPaused</A></B>(char&nbsp;drive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the pause status of the current CD audio track</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_CD_GetTrack(char)">FSOUND_CD_GetTrack</A></B>(char&nbsp;drive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the currently playing CD track number</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_CD_GetTrackLength(char, int)">FSOUND_CD_GetTrackLength</A></B>(char&nbsp;drive,
                         int&nbsp;track)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the track length of a CD</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_CD_GetTrackTime(char)">FSOUND_CD_GetTrackTime</A></B>(char&nbsp;drive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current track time playing on a CD
 
 <b>Remarks</b>
 This is easily one of the slowest functions in the FMOD API.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_CD_OpenTray(char, boolean)">FSOUND_CD_OpenTray</A></B>(char&nbsp;drive,
                   boolean&nbsp;open)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Opens/Closes the CD tray</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_CD_Play(char, int)">FSOUND_CD_Play</A></B>(char&nbsp;drive,
               int&nbsp;track)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plays a CD Audio track
 
 <b>Remarks</b>
 See FSOUND_CD_SetPlayMode for information on how to control playback of a CD track.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_CD_SetPaused(char, boolean)">FSOUND_CD_SetPaused</A></B>(char&nbsp;drive,
                    boolean&nbsp;paused)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the pause status of the currently playing CD audio track</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_CD_SetPlayMode(char, int)">FSOUND_CD_SetPlayMode</A></B>(char&nbsp;drive,
                      int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the playback mode of the CD</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_CD_SetTrackTime(char, int)">FSOUND_CD_SetTrackTime</A></B>(char&nbsp;drive,
                       int&nbsp;ms)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs a seek within a track specified by milliseconds
 
 <b>Remarks</b>
 This function will start the track if it is not playing
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_CD_SetVolume(char, int)">FSOUND_CD_SetVolume</A></B>(char&nbsp;drive,
                    int&nbsp;volume)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the volume of the playing CD audio</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_CD_Stop(char)">FSOUND_CD_Stop</A></B>(char&nbsp;drive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stops the currently playing CD audio track</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Close()">FSOUND_Close</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shuts down the WHOLE FMOD Sound System
 
 <b>Remarks</b>
 This also closes down the sample management system, freeing all MANAGED samples loaded (unless they were allocated with the FSOUND_UNMANAGED flag).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_ClearMixBuffer()">FSOUND_DSP_ClearMixBuffer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clears the mixbuffer, especially handy if you are doing a large file operation which 
 halts the system.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_Create(org.lwjgl.fmod3.callbacks.FSoundDSPCallback, int)">FSOUND_DSP_Create</A></B>(<A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundDSPCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundDSPCallback</A>&nbsp;callbackHandler,
                  int&nbsp;priority)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a DSP unit, and places it in the DSP chain position specified by the priority
 parameter.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_Free(org.lwjgl.fmod3.FSoundDSPUnit)">FSOUND_DSP_Free</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A>&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Frees and removes a DSP unit from the DSP chain</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_GetActive(org.lwjgl.fmod3.FSoundDSPUnit)">FSOUND_DSP_GetActive</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A>&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns if a DSP unit is active or not
 
 <b>Remarks</b>
 It is possible to toggle on and off FSOUNDs internal DSP units, though not recommended
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_GetBufferLength()">FSOUND_DSP_GetBufferLength</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the buffer lenth passed by the DSP system to DSP unit callbacks, so you can allocate memory etc 
 using this data
 
 <b>Remarks</b>
 Remember this is samples not bytes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_GetBufferLengthTotal()">FSOUND_DSP_GetBufferLengthTotal</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This is the total size in samples (not bytes) of the FSOUND mix buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_GetClearUnit()">FSOUND_DSP_GetClearUnit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a reference to FSOUND's system DSP clear unit
 
 <b>Remarks</b>
 The FSOUND clear DSP unit simply sets the mix buffer to 0, silencing it
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_GetClipAndCopyUnit()">FSOUND_DSP_GetClipAndCopyUnit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a reference to FSOUND's system Clip and Copy DSP unit
 
 <b>Remarks</b>
 The FSOUND ClipAndCopy DSP unit clips the 32bit buffer down to fit the soundcard's 16bit stereo output, and sends it off to the hardware.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_GetFFTUnit()">FSOUND_DSP_GetFFTUnit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a reference to FSOUND's system DSP FFT processing unit
 
 <b>Remarks</b>
 The FSOUND FFT DSP executes the FFT engine to allow FSOUND_DSP_GetSpectrum to be used.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_GetMusicUnit()">FSOUND_DSP_GetMusicUnit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a reference to FSOUND's system DSP Music mixer unit
 
 <b>Remarks</b>
 The FSOUND Music DSP executes the FMUSIC engine and mixes the sounds spawned by the music player
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_GetPriority(org.lwjgl.fmod3.FSoundDSPUnit)">FSOUND_DSP_GetPriority</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A>&nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the priority status in the DSP chain, of a specified unit.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_GetSFXUnit()">FSOUND_DSP_GetSFXUnit</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a reference to FSOUND's system DSP SFX mixer unit
 
 <b>Remarks</b>
 The FSOUND SFX DSP unit mixes sound effects together spawned by the user
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.nio.FloatBuffer</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_GetSpectrum()">FSOUND_DSP_GetSpectrum</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function to return a FloatBuffer to the current spectrum buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_MixBuffers(java.nio.ByteBuffer, java.nio.ByteBuffer, int, int, int, int, int)">FSOUND_DSP_MixBuffers</A></B>(java.nio.ByteBuffer&nbsp;destbuffer,
                      java.nio.ByteBuffer&nbsp;srcbuffer,
                      int&nbsp;len,
                      int&nbsp;freq,
                      int&nbsp;vol,
                      int&nbsp;pan,
                      int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allows the user to mix their own data from one buffer to another, using FSOUNDs optimized
 mixer routines.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_SetActive(org.lwjgl.fmod3.FSoundDSPUnit, boolean)">FSOUND_DSP_SetActive</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A>&nbsp;unit,
                     boolean&nbsp;active)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allows the user to toggle a DSP unit on or off
 
 <b>Remarks</b>
 It is possible to toggle on and off FSOUNDs internal DSP units, though not recommended
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_DSP_SetPriority(org.lwjgl.fmod3.FSoundDSPUnit, int)">FSOUND_DSP_SetPriority</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A>&nbsp;unit,
                       int&nbsp;priority)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Changes a DSP Unit's priority position in the DSP chain
 
 <b>Remarks</b>
 DSP units with the same priority as a previous unit already in the chain will be placed
 AFTER all like priority units
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_File_SetCallbacks(org.lwjgl.fmod3.callbacks.FSoundOpenCallback, org.lwjgl.fmod3.callbacks.FSoundCloseCallback, org.lwjgl.fmod3.callbacks.FSoundReadCallback, org.lwjgl.fmod3.callbacks.FSoundSeekCallback, org.lwjgl.fmod3.callbacks.FSoundTellCallback)">FSOUND_File_SetCallbacks</A></B>(<A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundOpenCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundOpenCallback</A>&nbsp;open,
                         <A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundCloseCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundCloseCallback</A>&nbsp;close,
                         <A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundReadCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundReadCallback</A>&nbsp;read,
                         <A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundSeekCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundSeekCallback</A>&nbsp;seek,
                         <A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundTellCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundTellCallback</A>&nbsp;tell)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Specify user callbacks for FMOD's internal file manipulation functions.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_Disable(int)">FSOUND_FX_Disable</A></B>(int&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Disables effect processing for ALL effects on the specified channel
 
 <b>Remarks</b>
 FSOUND_ALL is supported.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_Enable(int, int)">FSOUND_FX_Enable</A></B>(int&nbsp;channel,
                 int&nbsp;fxtype)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables effect processing for the specified channel.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_SetChorus(int, float, float, float, float, int, float, int)">FSOUND_FX_SetChorus</A></B>(int&nbsp;fxid,
                    float&nbsp;WetDryMix,
                    float&nbsp;Depth,
                    float&nbsp;Feedback,
                    float&nbsp;Frequency,
                    int&nbsp;Waveform,
                    float&nbsp;Delay,
                    int&nbsp;Phase)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the parameters for the chorus effect on a particular channel
 
 <b>Remarks</b>
 Make sure you have enabled this effect with FSOUND_FX_CHORUS before using this function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_SetCompressor(int, float, float, float, float, float, float)">FSOUND_FX_SetCompressor</A></B>(int&nbsp;fxid,
                        float&nbsp;Gain,
                        float&nbsp;Attack,
                        float&nbsp;Release,
                        float&nbsp;Threshold,
                        float&nbsp;Ratio,
                        float&nbsp;Predelay)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the parameters for the compressor effect on a particular channel
 
 <b>Remarks</b>
 Make sure you have enabled this effect with FSOUND_FX_COMPRESSOR before using this function   
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_SetDistortion(int, float, float, float, float, float)">FSOUND_FX_SetDistortion</A></B>(int&nbsp;fxid,
                        float&nbsp;Gain,
                        float&nbsp;Edge,
                        float&nbsp;PostEQCenterFrequency,
                        float&nbsp;PostEQBandwidth,
                        float&nbsp;PreLowpassCutoff)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the parameters for the distortion effect on a particular channel
 
 <b>Remarks</b>
 Make sure you have enabled this effect with FSOUND_FX_DISTORTION before using this function   
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_SetEcho(int, float, float, float, float, int)">FSOUND_FX_SetEcho</A></B>(int&nbsp;fxid,
                  float&nbsp;WetDryMix,
                  float&nbsp;Feedback,
                  float&nbsp;LeftDelay,
                  float&nbsp;RightDelay,
                  int&nbsp;PanDelay)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the parameters for the echo effect on a particular channel
 
 <b>Remarks</b>
 Make sure you have enabled this effect with FSOUND_FX_Enable and FSOUND_FX_ECHO before using this function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_SetFlanger(int, float, float, float, float, int, float, int)">FSOUND_FX_SetFlanger</A></B>(int&nbsp;fxid,
                     float&nbsp;WetDryMix,
                     float&nbsp;Depth,
                     float&nbsp;Feedback,
                     float&nbsp;Frequency,
                     int&nbsp;Waveform,
                     float&nbsp;Delay,
                     int&nbsp;Phase)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the parameters for the echo effect on a particular channel
 
 <b>Remarks</b>
 Make sure you have enabled this effect with FSOUND_FX_Enable and FSOUND_FX_FLANGER before using this function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_SetGargle(int, int, int)">FSOUND_FX_SetGargle</A></B>(int&nbsp;fxid,
                    int&nbsp;RateHz,
                    int&nbsp;WaveShape)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the parameters for the echo effect on a particular channel
 
 <b>Remarks</b>
 Make sure you have enabled this effect with FSOUND_FX_Enable and FSOUND_FX_GARGLE before using this function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_SetI3DL2Reverb(int, int, int, float, float, float, int, float, int, float, float, float, float)">FSOUND_FX_SetI3DL2Reverb</A></B>(int&nbsp;fxid,
                         int&nbsp;Room,
                         int&nbsp;RoomHF,
                         float&nbsp;RoomRolloffFactor,
                         float&nbsp;DecayTime,
                         float&nbsp;DecayHFRatio,
                         int&nbsp;Reflections,
                         float&nbsp;ReflectionsDelay,
                         int&nbsp;Reverb,
                         float&nbsp;ReverbDelay,
                         float&nbsp;Diffusion,
                         float&nbsp;Density,
                         float&nbsp;HFReference)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the parameters for the I3DL2 Reverb effect on a particular channel
 
 <b>Remarks</b>
 Make sure you have enabled this effect with FSOUND_FX_Enable and FSOUND_FX_I3DL2REVERB before using this function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_SetParamEQ(int, float, float, float)">FSOUND_FX_SetParamEQ</A></B>(int&nbsp;fxid,
                     float&nbsp;Center,
                     float&nbsp;Bandwidth,
                     float&nbsp;Gain)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the parameters for the I3DL2 Reverb effect on a particular channel
 
 <b>Remarks</b>
 Make sure you have enabled this effect with FSOUND_FX_Enable and FSOUND_FX_PARAMEQ before using this function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_FX_SetWavesReverb(int, float, float, float, float)">FSOUND_FX_SetWavesReverb</A></B>(int&nbsp;fxid,
                         float&nbsp;InGain,
                         float&nbsp;ReverbMix,
                         float&nbsp;ReverbTime,
                         float&nbsp;HighFreqRTRatio)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the parameters for the Waves Reverb effect on a particular channel
 
 <b>Remarks</b>
 Make sure you have enabled this effect with FSOUND_FX_Enable and FSOUND_WAVES_REVERB before using this function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetAmplitude(int)">FSOUND_GetAmplitude</A></B>(int&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the volume of the channel based on all combinations of set volume, mastervolume and 3d position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetChannelsPlaying()">FSOUND_GetChannelsPlaying</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of active channels in FSOUND, or ones that are playing</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetCPUUsage()">FSOUND_GetCPUUsage</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns in percent of cpu time the amount of cpu usage that FSOUND/FMUSIC mixing is taking
 
 <b>Remarks</b>
 This value represents the cpu usage used by streams, the software mixer, and subsequent calls to dsound waveout etc.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetCurrentLevels(int, java.nio.FloatBuffer)">FSOUND_GetCurrentLevels</A></B>(int&nbsp;channel,
                        java.nio.FloatBuffer&nbsp;l_r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a left and right VU/Level reading at the current position of the specified channel.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetCurrentPosition(int)">FSOUND_GetCurrentPosition</A></B>(int&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current playcursor position of the specified channel</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetCurrentSample(int)">FSOUND_GetCurrentSample</A></B>(int&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current sample being played on the specified channel
 
 <b>Remarks</b>
 Note that current sample does not return to NULL when a sound has ended.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetDriver()">FSOUND_GetDriver</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the currently selected driver number.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetDriverCaps(int, java.nio.IntBuffer)">FSOUND_GetDriverCaps</A></B>(int&nbsp;driverid,
                     java.nio.IntBuffer&nbsp;caps)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns information on capabilities of the current output mode</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetDriverName(int)">FSOUND_GetDriverName</A></B>(int&nbsp;driverid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the name of the selected driver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetError()">FSOUND_GetError</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an error code set by FMOD</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetFrequency(int)">FSOUND_GetFrequency</A></B>(int&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the frequency in HZ of the specified channel</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetLoopMode(int)">FSOUND_GetLoopMode</A></B>(int&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the loop mode for a particular channel
 
 <b>Remarks</b>
 This works for all channel types, whereas setting it will not work.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetMaxChannels()">FSOUND_GetMaxChannels</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the total number of channels allocated</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetMaxSamples()">FSOUND_GetMaxSamples</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current maximum index for a sample.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetMemoryStats(java.nio.IntBuffer)">FSOUND_GetMemoryStats</A></B>(java.nio.IntBuffer&nbsp;currentallocated_maxallocated)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns information on the memory usage of fmod.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetMixer()">FSOUND_GetMixer</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the currently used mixer type</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetMute(int)">FSOUND_GetMute</A></B>(int&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns if the channel specified is muted or not</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetNumDrivers()">FSOUND_GetNumDrivers</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of sound cards or devices enumerated for the current output type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetNumHWChannels(java.nio.IntBuffer)">FSOUND_GetNumHWChannels</A></B>(java.nio.IntBuffer&nbsp;twoD_threeD_channels_total)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of available hardware mixed 2d and 3d channels</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetNumSubChannels(int)">FSOUND_GetNumSubChannels</A></B>(int&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This function returns the number of sub-channels stored in a multi-channel channel handle, which is only possible when playing back a multichannel .FSB file.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetOutput()">FSOUND_GetOutput</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current id to the output type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetOutputRate()">FSOUND_GetOutputRate</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current mixing rate</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetPan(int)">FSOUND_GetPan</A></B>(int&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the linear pan position of the specified channel between 0 and 255</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetPaused(int)">FSOUND_GetPaused</A></B>(int&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets current pause status of the channel
 
 <b>Remarks</b>
  This function is useful for games that have a pause mode, and you dont want the sounds
  to continue playing, but you would like them to continue on from where they left off 
 when you unpause.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetPriority(int)">FSOUND_GetPriority</A></B>(int&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets a sound channels priority.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetReserved(int)">FSOUND_GetReserved</A></B>(int&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets a sound channels reserved status. priority is used to determine if soundeffects should muscle
 out other sound effects when the channel limit has been reached.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetSFXMasterVolume()">FSOUND_GetSFXMasterVolume</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the master volume for any sound effects played.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetSubChannel(int, int)">FSOUND_GetSubChannel</A></B>(int&nbsp;channel,
                     int&nbsp;subchannel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This function returns a channel handle from a subchannel within a multichannel FSB file, so that it can be maniuplated seperately, instead of controlling the whole multichannel array with the parent channel that the user retrieves from FSOUND_PlaySound etc.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetSurround(int)">FSOUND_GetSurround</A></B>(int&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the surround sound status of the specified channel.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetVersion()">FSOUND_GetVersion</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the FMOD version number
 
 <b>Remarks</b>
 Use this to compare the header you are using against the compiled DLL version to make sure your
 DLL is up to date.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_GetVolume(int)">FSOUND_GetVolume</A></B>(int&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the linear volume of the specified channel between 0 and 255</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Init(int, int, int)">FSOUND_Init</A></B>(int&nbsp;mixrate,
            int&nbsp;channels,
            int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initializes the FMOD Sound System.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_IsPlaying(int)">FSOUND_IsPlaying</A></B>(int&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns if the channel is currently playing or not.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_PlaySound(int, org.lwjgl.fmod3.FSoundSample)">FSOUND_PlaySound</A></B>(int&nbsp;channel,
                 <A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Plays a sample in a specified channel, using the sample's default frequency, volume
 and pan settings.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Record_GetDriver()">FSOUND_Record_GetDriver</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the currently selected recording driver number.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Record_GetDriverName(int)">FSOUND_Record_GetDriverName</A></B>(int&nbsp;id)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the name of the selected recording driver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Record_GetNumDrivers()">FSOUND_Record_GetNumDrivers</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of sound cards or devices enumerated for the current input type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Record_GetPosition()">FSOUND_Record_GetPosition</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the position in the sample buffer that has been recorded to
 
 <b>Remarks</b>
 Note.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Record_SetDriver(int)">FSOUND_Record_SetDriver</A></B>(int&nbsp;driverno)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the name of the selected recording driver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Record_StartSample(org.lwjgl.fmod3.FSoundSample, boolean)">FSOUND_Record_StartSample</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                          boolean&nbsp;loop)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Starts recording into a predefined sample using the sample's default playback rate as the recording rate
 
 <b>Remarks</b>
 If you want to play back the sample at the same time is is recording, you will have to play the sound and try and keep it just behind the recording cursor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Record_Stop()">FSOUND_Record_Stop</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Halts recording to the specified sample</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Reverb_GetChannelProperties(int, org.lwjgl.fmod3.FSoundReverbChannelProperties)">FSOUND_Reverb_GetChannelProperties</A></B>(int&nbsp;channel,
                                   <A HREF="../../../org/lwjgl/fmod3/FSoundReverbChannelProperties.html" title="class in org.lwjgl.fmod3">FSoundReverbChannelProperties</A>&nbsp;reverb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This function gets the current reverb properties for this channel</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Reverb_GetProperties(org.lwjgl.fmod3.FSoundReverbProperties)">FSOUND_Reverb_GetProperties</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundReverbProperties.html" title="class in org.lwjgl.fmod3">FSoundReverbProperties</A>&nbsp;reverb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current hardware reverb environment.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Reverb_SetChannelProperties(int, org.lwjgl.fmod3.FSoundReverbChannelProperties)">FSOUND_Reverb_SetChannelProperties</A></B>(int&nbsp;channel,
                                   <A HREF="../../../org/lwjgl/fmod3/FSoundReverbChannelProperties.html" title="class in org.lwjgl.fmod3">FSoundReverbChannelProperties</A>&nbsp;reverb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the channel specific reverb properties for hardware, including wet/dry mix (room size), and things like obstruction and occlusion properties
 
 <b>Remarks</b>
 FSOUND_ALL is supported here.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Reverb_SetProperties(org.lwjgl.fmod3.FSoundReverbProperties)">FSOUND_Reverb_SetProperties</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundReverbProperties.html" title="class in org.lwjgl.fmod3">FSoundReverbProperties</A>&nbsp;reverb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets hardware reverb parameters for advanced tuning.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_Alloc(int, int, int, int, int, int, int)">FSOUND_Sample_Alloc</A></B>(int&nbsp;index,
                    int&nbsp;length,
                    int&nbsp;mode,
                    int&nbsp;deffreq,
                    int&nbsp;defvol,
                    int&nbsp;defpan,
                    int&nbsp;defpri)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allocates a new empty sample.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_Free(org.lwjgl.fmod3.FSoundSample)">FSOUND_Sample_Free</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes a sample from memory and makes its slot available again</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_Get(int)">FSOUND_Sample_Get</A></B>(int&nbsp;sampno)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a reference to a managed sample based on the index passed
 
 <b>Remarks</b>
 Samples that are not created with FSOUND_UNMANAGED are stored in a table inside FMOD.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_GetDefaults(org.lwjgl.fmod3.FSoundSample, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)">FSOUND_Sample_GetDefaults</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                          java.nio.IntBuffer&nbsp;deffreq,
                          java.nio.IntBuffer&nbsp;defvol,
                          java.nio.IntBuffer&nbsp;defpan,
                          java.nio.IntBuffer&nbsp;defpri)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the default volume, frequency, pan and priority values for the specified sample
 
 <b>Remarks</b>
 Passing NULL in any of these parameters will result in the value being ignored
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_GetDefaultsEx(org.lwjgl.fmod3.FSoundSample, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)">FSOUND_Sample_GetDefaultsEx</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                            java.nio.IntBuffer&nbsp;deffreq,
                            java.nio.IntBuffer&nbsp;defvol,
                            java.nio.IntBuffer&nbsp;defpan,
                            java.nio.IntBuffer&nbsp;defpri,
                            java.nio.IntBuffer&nbsp;varfreq,
                            java.nio.IntBuffer&nbsp;varvol,
                            java.nio.IntBuffer&nbsp;varpan)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the default volume, frequency, pan, priority and random playback variations for the specified sample
 
 <b>Remarks</b>
 Passing NULL in any of these parameters will result in the value being ignored
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_GetLength(org.lwjgl.fmod3.FSoundSample)">FSOUND_Sample_GetLength</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the length of the sample in SAMPLES</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_GetLoopPoints(org.lwjgl.fmod3.FSoundSample, java.nio.IntBuffer, java.nio.IntBuffer)">FSOUND_Sample_GetLoopPoints</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                            java.nio.IntBuffer&nbsp;loopstart,
                            java.nio.IntBuffer&nbsp;loopend)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the start and end positions of the specified sample loop
 in SAMPLES (not bytes)
 
 <b>Remarks</b>
 Passing NULL in any of these parameters will result in the value being ignored.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_GetMinMaxDistance(org.lwjgl.fmod3.FSoundSample, java.nio.FloatBuffer, java.nio.FloatBuffer)">FSOUND_Sample_GetMinMaxDistance</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                                java.nio.FloatBuffer&nbsp;min,
                                java.nio.FloatBuffer&nbsp;max)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the minimum and maximum audible distance for a sample
 
 <b>Remarks</b>
 A 'distance unit' is specified by FSOUND_3D_SetDistanceFactor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_GetMode(org.lwjgl.fmod3.FSoundSample)">FSOUND_Sample_GetMode</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a bitfield containing information about the specified sample.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_GetName(org.lwjgl.fmod3.FSoundSample)">FSOUND_Sample_GetName</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a string containing the sample's name</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_Load(int, java.nio.ByteBuffer, int)">FSOUND_Sample_Load</A></B>(int&nbsp;index,
                   java.nio.ByteBuffer&nbsp;data,
                   int&nbsp;inputmode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Loads and decodes a static soundfile into memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_Load(int, java.lang.String, int, int, int)">FSOUND_Sample_Load</A></B>(int&nbsp;index,
                   java.lang.String&nbsp;name,
                   int&nbsp;inputmode,
                   int&nbsp;offset,
                   int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_Lock(org.lwjgl.fmod3.FSoundSample, int, int, org.lwjgl.fmod3.FSoundSampleLock)">FSOUND_Sample_Lock</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                   int&nbsp;offset,
                   int&nbsp;length,
                   <A HREF="../../../org/lwjgl/fmod3/FSoundSampleLock.html" title="class in org.lwjgl.fmod3">FSoundSampleLock</A>&nbsp;lock)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a reference to the beginning of the sample data for a sample.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_SetDefaults(org.lwjgl.fmod3.FSoundSample, int, int, int, int)">FSOUND_Sample_SetDefaults</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                          int&nbsp;deffreq,
                          int&nbsp;defvol,
                          int&nbsp;defpan,
                          int&nbsp;defpri)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a sample's default attributes, so when it is played it uses these values without having to specify them later.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_SetDefaultsEx(org.lwjgl.fmod3.FSoundSample, int, int, int, int, int, int, int)">FSOUND_Sample_SetDefaultsEx</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                            int&nbsp;deffreq,
                            int&nbsp;defvol,
                            int&nbsp;defpan,
                            int&nbsp;defpri,
                            int&nbsp;varfreq,
                            int&nbsp;varvol,
                            int&nbsp;varpan)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a sample's default attributes, so when it is played it uses these values without having to specify them later.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_SetMaxPlaybacks(org.lwjgl.fmod3.FSoundSample, int)">FSOUND_Sample_SetMaxPlaybacks</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                              int&nbsp;max)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the maximum number of times a sample can play back at once</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_SetMinMaxDistance(org.lwjgl.fmod3.FSoundSample, float, float)">FSOUND_Sample_SetMinMaxDistance</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                                float&nbsp;min,
                                float&nbsp;max)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the minimum and maximum audible distance for a sample.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_SetMode(org.lwjgl.fmod3.FSoundSample, int)">FSOUND_Sample_SetMode</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                      int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a sample's mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_Unlock(org.lwjgl.fmod3.FSoundSample, org.lwjgl.fmod3.FSoundSampleLock)">FSOUND_Sample_Unlock</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                     <A HREF="../../../org/lwjgl/fmod3/FSoundSampleLock.html" title="class in org.lwjgl.fmod3">FSoundSampleLock</A>&nbsp;lock)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Releases previous sample data lock from FSOUND_Sample_Lock</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Sample_Upload(org.lwjgl.fmod3.FSoundSample, java.nio.ByteBuffer, int)">FSOUND_Sample_Upload</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                     java.nio.ByteBuffer&nbsp;srcdata,
                     int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This function uploads new sound data from memory to a preallocated/existing sample and does conversion based on the specified source mode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetBufferSize(int)">FSOUND_SetBufferSize</A></B>(int&nbsp;len_ms)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the FMOD internal mixing buffer size.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetCurrentPosition(int, int)">FSOUND_SetCurrentPosition</A></B>(int&nbsp;channel,
                          int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current position of the sound in SAMPLES not bytes
 
 <b>Remarks</b>
 FSOUND_ALL is supported.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetDriver(int)">FSOUND_SetDriver</A></B>(int&nbsp;driver)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selects a soundcard driver.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetFrequency(int, int)">FSOUND_SetFrequency</A></B>(int&nbsp;channel,
                    int&nbsp;freq)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a channels frequency or playback rate, in Hz.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetLevels(int, int, int, int, int, int, int)">FSOUND_SetLevels</A></B>(int&nbsp;channel,
                 int&nbsp;frontleft,
                 int&nbsp;center,
                 int&nbsp;frontright,
                 int&nbsp;backleft,
                 int&nbsp;backright,
                 int&nbsp;lfe)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;XBox Only - For surround sound systems, this function allows each surround speaker level to be set individually for this channel
 
 <b>Remarks</b>
 FSOUND_ALL is supported.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetLoopMode(int, int)">FSOUND_SetLoopMode</A></B>(int&nbsp;channel,
                   int&nbsp;loopmode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the loop mode for a particular CHANNEL, not sample
 
 <b>Remarks</b>
 FSOUND_ALL is supported.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetMaxHardwareChannels(int)">FSOUND_SetMaxHardwareChannels</A></B>(int&nbsp;max)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This sets the maximum allocatable channels on a hardware card.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetMinHardwareChannels(int)">FSOUND_SetMinHardwareChannels</A></B>(int&nbsp;min)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This sets the minimum allowable hardware channels before FMOD drops back to 100 percent software.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetMixer(int)">FSOUND_SetMixer</A></B>(int&nbsp;mixer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a digital mixer type.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetMute(int, boolean)">FSOUND_SetMute</A></B>(int&nbsp;channel,
               boolean&nbsp;mute)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mutes and un-mutes a channel
 
 <b>Remarks</b>
 FSOUND_ALL is supported.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetOutput(int)">FSOUND_SetOutput</A></B>(int&nbsp;output)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets up the soundsystem output mode
 
 <b>Remarks</b>
 This function cannot be called after FMOD is already activated with FSOUND_Init.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetPan(int, int)">FSOUND_SetPan</A></B>(int&nbsp;channel,
              int&nbsp;pan)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a channels pan position linearly
 
 <b>Remarks</b>
 FSOUND_ALL is supported.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetPanSeperation(float)">FSOUND_SetPanSeperation</A></B>(float&nbsp;pansep)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the master pan seperation for 2d sound effects</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetPaused(int, boolean)">FSOUND_SetPaused</A></B>(int&nbsp;channel,
                 boolean&nbsp;paused)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Pauses or unpauses a sound channel
 
 <b>Remarks</b>
 FSOUND_ALL is supported.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetPriority(int, int)">FSOUND_SetPriority</A></B>(int&nbsp;channel,
                   int&nbsp;priority)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a channels priority.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetReserved(int, boolean)">FSOUND_SetReserved</A></B>(int&nbsp;channel,
                   boolean&nbsp;reserved)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This sets the reserved status of a channel.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetSFXMasterVolume(int)">FSOUND_SetSFXMasterVolume</A></B>(int&nbsp;volume)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the master volume for any sound effects played.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetSpeakerMode(int)">FSOUND_SetSpeakerMode</A></B>(int&nbsp;speakermode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the mode for the users speaker setup
 
 <b>Remarks</b>
 Note - Only reliably works with FSOUND_OUTPUT_DSOUND or FSOUND_OUTPUT_XBOX output modes.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetSurround(int, boolean)">FSOUND_SetSurround</A></B>(int&nbsp;channel,
                   boolean&nbsp;surround)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a channels surround sound status.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetVolume(int, int)">FSOUND_SetVolume</A></B>(int&nbsp;channel,
                 int&nbsp;vol)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a channels volume linearly.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_SetVolumeAbsolute(int, int)">FSOUND_SetVolumeAbsolute</A></B>(int&nbsp;channel,
                         int&nbsp;vol)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a channels volume linearly.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_StopSound(int)">FSOUND_StopSound</A></B>(int&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stops a specified sound channel from playing, and frees it up for re-use
 
 <b>Remarks</b>
 FSOUND_ALL is supported.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundSyncPoint.html" title="class in org.lwjgl.fmod3">FSoundSyncPoint</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_AddSyncPoint(org.lwjgl.fmod3.FSoundStream, int, java.lang.String)">FSOUND_Stream_AddSyncPoint</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                           int&nbsp;pcmoffset,
                           java.lang.String&nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a user synchronization callback point into a stream
 
 <b>Remarks</b>
 If the stream has been opened with FSOUND_NONBLOCKING, this function will not succeed until the stream is ready   
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_Close(org.lwjgl.fmod3.FSoundStream)">FSOUND_Stream_Close</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shuts down and releases an FSOUND stream
 
 <b>Remarks</b>
 If the stream has been opened with FSOUND_NONBLOCKING, this function will not succeed until the stream is ready.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_Create(org.lwjgl.fmod3.callbacks.FSoundStreamCallback, int, int, int)">FSOUND_Stream_Create</A></B>(<A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundStreamCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundStreamCallback</A>&nbsp;callbackHandler,
                     int&nbsp;lenbytes,
                     int&nbsp;mode,
                     int&nbsp;samplerate)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a user definable stream file ready for playing.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_CreateDSP(org.lwjgl.fmod3.FSoundStream, org.lwjgl.fmod3.callbacks.FSoundDSPCallback, int)">FSOUND_Stream_CreateDSP</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                        <A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundDSPCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundDSPCallback</A>&nbsp;callback,
                        int&nbsp;priority)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Allows the user to add a custom DSP unit to a stream
 
 <b>Remarks</b>
 The priority for a stream DSP unit is not related to the priorities specified in fmod.h.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_DeleteSyncPoint(org.lwjgl.fmod3.FSoundSyncPoint)">FSOUND_Stream_DeleteSyncPoint</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSyncPoint.html" title="class in org.lwjgl.fmod3">FSoundSyncPoint</A>&nbsp;point)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes a user synchronization callback point from a stream.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_FindTagField(org.lwjgl.fmod3.FSoundStream, org.lwjgl.fmod3.FSoundTagField)">FSOUND_Stream_FindTagField</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                           <A HREF="../../../org/lwjgl/fmod3/FSoundTagField.html" title="class in org.lwjgl.fmod3">FSoundTagField</A>&nbsp;field)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find a tag field associated with an open stream by name and type</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_GetLength(org.lwjgl.fmod3.FSoundStream)">FSOUND_Stream_GetLength</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the size of the stream in BYTES
 
 <b>Remarks</b>
 Position functions for streams work in bytes not samples.
 -----
 This function is not supported for URL based streams over the internet.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_GetLengthMs(org.lwjgl.fmod3.FSoundStream)">FSOUND_Stream_GetLengthMs</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the size of the stream in MILLISECONDS
 
 <b>Remarks</b>
 FSOUND_MPEGACCURATE will need to be used with mp3 files that use VBR encoding for more accuracy
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_GetMode(org.lwjgl.fmod3.FSoundStream)">FSOUND_Stream_GetMode</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the mode of the stream
 
 <b>Remarks</b>
 If the stream has been opened with FSOUND_NONBLOCKING, this function will not succeed until the stream is ready.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_GetNumSubStreams(org.lwjgl.fmod3.FSoundStream)">FSOUND_Stream_GetNumSubStreams</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of substreams inside a multi-stream FSB bank file</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_GetNumTagFields(org.lwjgl.fmod3.FSoundStream, java.nio.IntBuffer)">FSOUND_Stream_GetNumTagFields</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                              java.nio.IntBuffer&nbsp;num)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the number of tag fields associated with the specified stream</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_GetOpenState(org.lwjgl.fmod3.FSoundStream)">FSOUND_Stream_GetOpenState</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;If a stream is opened with FSOUND_NONBLOCKING, this function returns the state of the opening stream
 
 <b>Remarks</b>
 A blocking stream will return NULL from FSOUND_Stream_Open so a return value of -3 is redundant in this case.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_GetPosition(org.lwjgl.fmod3.FSoundStream)">FSOUND_Stream_GetPosition</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current FILE position of the stream of the stream in BYTES
 
 <b>Remarks</b>
 Position functions for streams work in bytes not samples.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_GetSample(org.lwjgl.fmod3.FSoundStream)">FSOUND_Stream_GetSample</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the FSOUND_SAMPLE definition that the stream uses internally.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundSyncPoint.html" title="class in org.lwjgl.fmod3">FSoundSyncPoint</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_GetSyncPoint(org.lwjgl.fmod3.FSoundStream, int)">FSOUND_Stream_GetSyncPoint</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                           int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Obtains a sync point by index.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_GetSyncPointInfo(org.lwjgl.fmod3.FSoundSyncPoint, java.nio.IntBuffer)">FSOUND_Stream_GetSyncPointInfo</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSyncPoint.html" title="class in org.lwjgl.fmod3">FSoundSyncPoint</A>&nbsp;point,
                               java.nio.IntBuffer&nbsp;pcmoffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves the name and pcm offset in samples for a specified sync point
 
 <b>Remarks</b>
 Convert samples to time by dividing the PCM value by the default samplerate.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_GetTagField(org.lwjgl.fmod3.FSoundStream, int, org.lwjgl.fmod3.FSoundTagField)">FSOUND_Stream_GetTagField</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                          int&nbsp;num,
                          <A HREF="../../../org/lwjgl/fmod3/FSoundTagField.html" title="class in org.lwjgl.fmod3">FSoundTagField</A>&nbsp;field)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get a tag field associated with an open stream
 
 <b>Remarks</b>
 If this function returns successfully, "value" will contain a pointer to a piece of tag-field-specific data - do not assume it will always point to a null-terminated ASCII string.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_GetTime(org.lwjgl.fmod3.FSoundStream)">FSOUND_Stream_GetTime</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current time offset in stream in milliseconds.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_Net_GetBufferProperties(java.nio.IntBuffer)">FSOUND_Stream_Net_GetBufferProperties</A></B>(java.nio.IntBuffer&nbsp;values)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets buffer size and thresholds that will be used when opening new internet streams
 
 <b>Remarks</b>
 This function returns the values that will be used for subsequent internet stream opens.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_Net_GetLastServerStatus()">FSOUND_Stream_Net_GetLastServerStatus</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This function returns a String representing the last HTTP status line that was received when connecting to an internet stream
 
 <b>Remarks</b>
 The result of this function should be used for informational purposes only.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_Net_GetStatus(org.lwjgl.fmod3.FSoundStream, java.nio.IntBuffer)">FSOUND_Stream_Net_GetStatus</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                            java.nio.IntBuffer&nbsp;values)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get various status information for an internet stream</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_Net_SetBufferProperties(int, int, int)">FSOUND_Stream_Net_SetBufferProperties</A></B>(int&nbsp;buffersize,
                                      int&nbsp;prebuffer_percent,
                                      int&nbsp;rebuffer_percent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets buffer size and thresholds to use when opening new internet streams
 
 <b>Remarks</b>
 Call this function before FSOUND_Stream_Open.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_Net_SetMetadataCallback(org.lwjgl.fmod3.FSoundStream, org.lwjgl.fmod3.callbacks.FSoundMetaDataCallback)">FSOUND_Stream_Net_SetMetadataCallback</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                      <A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundMetaDataCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundMetaDataCallback</A>&nbsp;callback)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set a metadata callback for an internet stream
 
 <b>Remarks</b>
 The supplied metadata callback function will be called each time the specified internet stream receives a chunk of metadata.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_Net_SetProxy(java.lang.String)">FSOUND_Stream_Net_SetProxy</A></B>(java.lang.String&nbsp;proxy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set a proxy server to use for all subsequent internet connections</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_Open(java.nio.ByteBuffer, int)">FSOUND_Stream_Open</A></B>(java.nio.ByteBuffer&nbsp;data,
                   int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_Open(java.lang.String, int, int, int)">FSOUND_Stream_Open</A></B>(java.lang.String&nbsp;name,
                   int&nbsp;mode,
                   int&nbsp;offset,
                   int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Opens an audio file/url/cd ready for streaming.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_Play(int, org.lwjgl.fmod3.FSoundStream)">FSOUND_Stream_Play</A></B>(int&nbsp;channel,
                   <A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Starts a pre-opened stream playing
 
 <b>Remarks</b>
 When a stream starts to play, it inherits a special high priority (256).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_PlayEx(int, org.lwjgl.fmod3.FSoundStream, org.lwjgl.fmod3.FSoundDSPUnit, boolean)">FSOUND_Stream_PlayEx</A></B>(int&nbsp;channel,
                     <A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                     <A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A>&nbsp;dspunit,
                     boolean&nbsp;paused)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended featured version of FSOUND_Stream_Play.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_SetBufferSize(int)">FSOUND_Stream_SetBufferSize</A></B>(int&nbsp;ms)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the internal file buffersize for audio streaming of data for the NEXT stream opened with FSOUND_Stream_Open.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_SetEndCallback(org.lwjgl.fmod3.FSoundStream, org.lwjgl.fmod3.callbacks.FSoundStreamCallback)">FSOUND_Stream_SetEndCallback</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                             <A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundStreamCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundStreamCallback</A>&nbsp;callback)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a callback function for when a stream has ended
 
 <b>Remarks</b>
 Only calls back when a stream stops.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_SetLoopCount(org.lwjgl.fmod3.FSoundStream, int)">FSOUND_Stream_SetLoopCount</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                           int&nbsp;count)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the stream to loop the number of times specified by the user.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_SetLoopPoints(org.lwjgl.fmod3.FSoundStream, int, int)">FSOUND_Stream_SetLoopPoints</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                            int&nbsp;loopstart,
                            int&nbsp;loopend)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the loop points for a stream
 
 <b>Remarks</b>
 For streams, setting looppoints is reasonably accurate but should not be assumed to be perfectly sample accurate in all cases.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_SetMode(org.lwjgl.fmod3.FSoundStream, int)">FSOUND_Stream_SetMode</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                      int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set a streams mode
 
 <b>Remarks</b>
 If the stream has been opened with FSOUND_NONBLOCKING, this function will not succeed until the stream is ready.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_SetPosition(org.lwjgl.fmod3.FSoundStream, int)">FSOUND_Stream_SetPosition</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                          int&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set a streams mode
 
 <b>Remarks</b>
 Position functions for streams talk in bytes and NOT samples.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_SetSubStream(org.lwjgl.fmod3.FSoundStream, int)">FSOUND_Stream_SetSubStream</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                           int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Seeks a stream to the substream inside a multi-stream FSB bank file, specified by its index
 
 <b>Remarks</b>
 A stream will stop if this function is called, as it needs to seek and flush the buffer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_SetSubStreamSentence(org.lwjgl.fmod3.FSoundStream, java.nio.IntBuffer)">FSOUND_Stream_SetSubStreamSentence</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                   java.nio.IntBuffer&nbsp;sentencelist)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This function allows the user to describe the playback order of a list of substreams.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_SetSyncCallback(org.lwjgl.fmod3.FSoundStream, org.lwjgl.fmod3.callbacks.FSoundStreamCallback)">FSOUND_Stream_SetSyncCallback</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                              <A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundStreamCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundStreamCallback</A>&nbsp;callback)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a callback function for when a stream passes over a WAV tag/marker.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_SetTime(org.lwjgl.fmod3.FSoundStream, int)">FSOUND_Stream_SetTime</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                      int&nbsp;ms)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current stream's FILE position in MILLISECONDS
 
 <b>Remarks</b>
 If the stream has been opened with FSOUND_NONBLOCKING, this function will not succeed until the stream is ready.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_Stop(org.lwjgl.fmod3.FSoundStream)">FSOUND_Stream_Stop</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stops a stream from playing
 
 <b>Remarks</b>
 The stream is still prepared and sitting in memory ready to go.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Update()">FSOUND_Update</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;This updates the 3d sound engine and DMA engine (only on some platforms), and should be called once a game frame.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#nFSOUND_PlaySoundEx(int, org.lwjgl.fmod3.FSoundSample, org.lwjgl.fmod3.FSoundDSPUnit, boolean)">nFSOUND_PlaySoundEx</A></B>(int&nbsp;channel,
                    <A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                    <A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A>&nbsp;dspunit,
                    boolean&nbsp;startpaused)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extended featured version of FSOUND_PlaySound.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#nFSOUND_Sample_SetLoopPoints(org.lwjgl.fmod3.FSoundSample, int, int)">nFSOUND_Sample_SetLoopPoints</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                             int&nbsp;loopstart,
                             int&nbsp;loopend)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets a sample's loop points, specified in SAMPLES, not bytes
 
 <b>Remarks</b>
 Samples created with FSOUND_HW3D and FSOUND_HW2D under the FSOUND_OUTPUT_DSOUND output mode do not support this function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/lwjgl/fmod3/FSound.html#nFSOUND_Stream_GetNumSyncPoints(org.lwjgl.fmod3.FSoundStream)">nFSOUND_Stream_GetNumSyncPoints</A></B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of substreams inside a multi-stream FSB bank file</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="FSOUND_MIXER_AUTODETECT"><!-- --></A><H3>
FSOUND_MIXER_AUTODETECT</H3>
<PRE>
public static final int <B>FSOUND_MIXER_AUTODETECT</B></PRE>
<DL>
<DD>CE/PS2/GC Only - Non interpolating/low quality mixer.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_MIXER_AUTODETECT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_MIXER_BLENDMODE"><!-- --></A><H3>
FSOUND_MIXER_BLENDMODE</H3>
<PRE>
public static final int <B>FSOUND_MIXER_BLENDMODE</B></PRE>
<DL>
<DD>Removed / obsolete.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_MIXER_BLENDMODE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_MIXER_MMXP5"><!-- --></A><H3>
FSOUND_MIXER_MMXP5</H3>
<PRE>
public static final int <B>FSOUND_MIXER_MMXP5</B></PRE>
<DL>
<DD>Removed / obsolete.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_MIXER_MMXP5">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_MIXER_MMXP6"><!-- --></A><H3>
FSOUND_MIXER_MMXP6</H3>
<PRE>
public static final int <B>FSOUND_MIXER_MMXP6</B></PRE>
<DL>
<DD>Removed / obsolete.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_MIXER_MMXP6">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_MIXER_QUALITY_AUTODETECT"><!-- --></A><H3>
FSOUND_MIXER_QUALITY_AUTODETECT</H3>
<PRE>
public static final int <B>FSOUND_MIXER_QUALITY_AUTODETECT</B></PRE>
<DL>
<DD>All platforms - Autodetect the fastest quality mixer based on your cpu.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_MIXER_QUALITY_AUTODETECT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_MIXER_QUALITY_FPU"><!-- --></A><H3>
FSOUND_MIXER_QUALITY_FPU</H3>
<PRE>
public static final int <B>FSOUND_MIXER_QUALITY_FPU</B></PRE>
<DL>
<DD>Win32/Linux only - Interpolating/volume ramping FPU mixer.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_MIXER_QUALITY_FPU">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_MIXER_QUALITY_MMXP5"><!-- --></A><H3>
FSOUND_MIXER_QUALITY_MMXP5</H3>
<PRE>
public static final int <B>FSOUND_MIXER_QUALITY_MMXP5</B></PRE>
<DL>
<DD>Win32/Linux only - Interpolating/volume ramping P5 MMX mixer.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_MIXER_QUALITY_MMXP5">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_MIXER_QUALITY_MMXP6"><!-- --></A><H3>
FSOUND_MIXER_QUALITY_MMXP6</H3>
<PRE>
public static final int <B>FSOUND_MIXER_QUALITY_MMXP6</B></PRE>
<DL>
<DD>Win32/Linux only - Interpolating/volume ramping ppro+ MMX mixer.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_MIXER_QUALITY_MMXP6">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_MIXER_MONO"><!-- --></A><H3>
FSOUND_MIXER_MONO</H3>
<PRE>
public static final int <B>FSOUND_MIXER_MONO</B></PRE>
<DL>
<DD>CE/PS2/GC only - MONO non interpolating/low quality mixer. For speed
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_MIXER_MONO">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_MIXER_QUALITY_MONO"><!-- --></A><H3>
FSOUND_MIXER_QUALITY_MONO</H3>
<PRE>
public static final int <B>FSOUND_MIXER_QUALITY_MONO</B></PRE>
<DL>
<DD>CE/PS2/GC only - MONO Interpolating mixer.  For speed
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_MIXER_QUALITY_MONO">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_MIXER_MAX"><!-- --></A><H3>
FSOUND_MIXER_MAX</H3>
<PRE>
public static final int <B>FSOUND_MIXER_MAX</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_MIXER_MAX">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_OUTPUT_NOSOUND"><!-- --></A><H3>
FSOUND_OUTPUT_NOSOUND</H3>
<PRE>
public static final int <B>FSOUND_OUTPUT_NOSOUND</B></PRE>
<DL>
<DD>NoSound driver, all calls to this succeed but do nothing.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_OUTPUT_NOSOUND">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_OUTPUT_WINMM"><!-- --></A><H3>
FSOUND_OUTPUT_WINMM</H3>
<PRE>
public static final int <B>FSOUND_OUTPUT_WINMM</B></PRE>
<DL>
<DD>Windows Multimedia driver.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_OUTPUT_WINMM">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_OUTPUT_DSOUND"><!-- --></A><H3>
FSOUND_OUTPUT_DSOUND</H3>
<PRE>
public static final int <B>FSOUND_OUTPUT_DSOUND</B></PRE>
<DL>
<DD>DirectSound driver.  You need this to get EAX or EAX2 support, or FX api support.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_OUTPUT_DSOUND">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_OUTPUT_A3D"><!-- --></A><H3>
FSOUND_OUTPUT_A3D</H3>
<PRE>
public static final int <B>FSOUND_OUTPUT_A3D</B></PRE>
<DL>
<DD>A3D driver.  not supported any more.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_OUTPUT_A3D">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_OUTPUT_OSS"><!-- --></A><H3>
FSOUND_OUTPUT_OSS</H3>
<PRE>
public static final int <B>FSOUND_OUTPUT_OSS</B></PRE>
<DL>
<DD>Linux/Unix OSS (Open Sound System) driver, i.e. the kernel sound drivers.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_OUTPUT_OSS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_OUTPUT_ESD"><!-- --></A><H3>
FSOUND_OUTPUT_ESD</H3>
<PRE>
public static final int <B>FSOUND_OUTPUT_ESD</B></PRE>
<DL>
<DD>Linux/Unix ESD (Enlightment Sound Daemon) driver.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_OUTPUT_ESD">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_OUTPUT_ALSA"><!-- --></A><H3>
FSOUND_OUTPUT_ALSA</H3>
<PRE>
public static final int <B>FSOUND_OUTPUT_ALSA</B></PRE>
<DL>
<DD>Linux Alsa driver.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_OUTPUT_ALSA">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_OUTPUT_ASIO"><!-- --></A><H3>
FSOUND_OUTPUT_ASIO</H3>
<PRE>
public static final int <B>FSOUND_OUTPUT_ASIO</B></PRE>
<DL>
<DD>Low latency ASIO driver
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_OUTPUT_ASIO">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_OUTPUT_XBOX"><!-- --></A><H3>
FSOUND_OUTPUT_XBOX</H3>
<PRE>
public static final int <B>FSOUND_OUTPUT_XBOX</B></PRE>
<DL>
<DD>Xbox driver
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_OUTPUT_XBOX">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_OUTPUT_PS2"><!-- --></A><H3>
FSOUND_OUTPUT_PS2</H3>
<PRE>
public static final int <B>FSOUND_OUTPUT_PS2</B></PRE>
<DL>
<DD>PlayStation 2 driver
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_OUTPUT_PS2">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_OUTPUT_MAC"><!-- --></A><H3>
FSOUND_OUTPUT_MAC</H3>
<PRE>
public static final int <B>FSOUND_OUTPUT_MAC</B></PRE>
<DL>
<DD>Mac SoundMager driver
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_OUTPUT_MAC">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_OUTPUT_GC"><!-- --></A><H3>
FSOUND_OUTPUT_GC</H3>
<PRE>
public static final int <B>FSOUND_OUTPUT_GC</B></PRE>
<DL>
<DD>Gamecube driver
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_OUTPUT_GC">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_OUTPUT_NOSOUND_NONREALTIME"><!-- --></A><H3>
FSOUND_OUTPUT_NOSOUND_NONREALTIME</H3>
<PRE>
public static final int <B>FSOUND_OUTPUT_NOSOUND_NONREALTIME</B></PRE>
<DL>
<DD>This is the same As nosound, but the sound generation is driven by FSOUND_Update
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_OUTPUT_NOSOUND_NONREALTIME">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_DSP_DEFAULTPRIORITY_CLEARUNIT"><!-- --></A><H3>
FSOUND_DSP_DEFAULTPRIORITY_CLEARUNIT</H3>
<PRE>
public static final int <B>FSOUND_DSP_DEFAULTPRIORITY_CLEARUNIT</B></PRE>
<DL>
<DD>DSP CLEAR unit - done first
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_DSP_DEFAULTPRIORITY_CLEARUNIT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_DSP_DEFAULTPRIORITY_SFXUNIT"><!-- --></A><H3>
FSOUND_DSP_DEFAULTPRIORITY_SFXUNIT</H3>
<PRE>
public static final int <B>FSOUND_DSP_DEFAULTPRIORITY_SFXUNIT</B></PRE>
<DL>
<DD>DSP SFX unit - done second
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_DSP_DEFAULTPRIORITY_SFXUNIT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_DSP_DEFAULTPRIORITY_MUSICUNIT"><!-- --></A><H3>
FSOUND_DSP_DEFAULTPRIORITY_MUSICUNIT</H3>
<PRE>
public static final int <B>FSOUND_DSP_DEFAULTPRIORITY_MUSICUNIT</B></PRE>
<DL>
<DD>DSP MUSIC unit - done third
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_DSP_DEFAULTPRIORITY_MUSICUNIT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_DSP_DEFAULTPRIORITY_USER"><!-- --></A><H3>
FSOUND_DSP_DEFAULTPRIORITY_USER</H3>
<PRE>
public static final int <B>FSOUND_DSP_DEFAULTPRIORITY_USER</B></PRE>
<DL>
<DD>User priority, use this as reference
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_DSP_DEFAULTPRIORITY_USER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_DSP_DEFAULTPRIORITY_FFTUNIT"><!-- --></A><H3>
FSOUND_DSP_DEFAULTPRIORITY_FFTUNIT</H3>
<PRE>
public static final int <B>FSOUND_DSP_DEFAULTPRIORITY_FFTUNIT</B></PRE>
<DL>
<DD>This reads data for FSOUND_DSP_GetSpectrum, so it comes after user units
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_DSP_DEFAULTPRIORITY_FFTUNIT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_DSP_DEFAULTPRIORITY_CLIPANDCOPYUNIT"><!-- --></A><H3>
FSOUND_DSP_DEFAULTPRIORITY_CLIPANDCOPYUNIT</H3>
<PRE>
public static final int <B>FSOUND_DSP_DEFAULTPRIORITY_CLIPANDCOPYUNIT</B></PRE>
<DL>
<DD>DSP CLIP AND COPY unit - last
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_DSP_DEFAULTPRIORITY_CLIPANDCOPYUNIT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_CAPS_HARDWARE"><!-- --></A><H3>
FSOUND_CAPS_HARDWARE</H3>
<PRE>
public static final int <B>FSOUND_CAPS_HARDWARE</B></PRE>
<DL>
<DD>This driver supports hardware accelerated 3d sound.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_CAPS_HARDWARE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_CAPS_EAX2"><!-- --></A><H3>
FSOUND_CAPS_EAX2</H3>
<PRE>
public static final int <B>FSOUND_CAPS_EAX2</B></PRE>
<DL>
<DD>This driver supports EAX2 reverb
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_CAPS_EAX2">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_CAPS_EAX3"><!-- --></A><H3>
FSOUND_CAPS_EAX3</H3>
<PRE>
public static final int <B>FSOUND_CAPS_EAX3</B></PRE>
<DL>
<DD>This driver supports EAX3 reverb
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_CAPS_EAX3">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_LOOP_OFF"><!-- --></A><H3>
FSOUND_LOOP_OFF</H3>
<PRE>
public static final int <B>FSOUND_LOOP_OFF</B></PRE>
<DL>
<DD>For non looping samples.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_LOOP_OFF">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_LOOP_NORMAL"><!-- --></A><H3>
FSOUND_LOOP_NORMAL</H3>
<PRE>
public static final int <B>FSOUND_LOOP_NORMAL</B></PRE>
<DL>
<DD>For forward looping samples.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_LOOP_NORMAL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_LOOP_BIDI"><!-- --></A><H3>
FSOUND_LOOP_BIDI</H3>
<PRE>
public static final int <B>FSOUND_LOOP_BIDI</B></PRE>
<DL>
<DD>For bidirectional looping samples.  (no effect if in hardware).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_LOOP_BIDI">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_8BITS"><!-- --></A><H3>
FSOUND_8BITS</H3>
<PRE>
public static final int <B>FSOUND_8BITS</B></PRE>
<DL>
<DD>For 8 bit samples.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_8BITS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_16BITS"><!-- --></A><H3>
FSOUND_16BITS</H3>
<PRE>
public static final int <B>FSOUND_16BITS</B></PRE>
<DL>
<DD>For 16 bit samples.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_16BITS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_MONO"><!-- --></A><H3>
FSOUND_MONO</H3>
<PRE>
public static final int <B>FSOUND_MONO</B></PRE>
<DL>
<DD>For mono samples.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_MONO">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_STEREO"><!-- --></A><H3>
FSOUND_STEREO</H3>
<PRE>
public static final int <B>FSOUND_STEREO</B></PRE>
<DL>
<DD>For stereo samples.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_STEREO">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_UNSIGNED"><!-- --></A><H3>
FSOUND_UNSIGNED</H3>
<PRE>
public static final int <B>FSOUND_UNSIGNED</B></PRE>
<DL>
<DD>For user created source data containing unsigned samples.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_UNSIGNED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_SIGNED"><!-- --></A><H3>
FSOUND_SIGNED</H3>
<PRE>
public static final int <B>FSOUND_SIGNED</B></PRE>
<DL>
<DD>For user created source data containing signed data.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_SIGNED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_DELTA"><!-- --></A><H3>
FSOUND_DELTA</H3>
<PRE>
public static final int <B>FSOUND_DELTA</B></PRE>
<DL>
<DD>For user created source data stored as delta values.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_DELTA">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_IT214"><!-- --></A><H3>
FSOUND_IT214</H3>
<PRE>
public static final int <B>FSOUND_IT214</B></PRE>
<DL>
<DD>For user created source data stored using IT214 compression.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_IT214">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_IT215"><!-- --></A><H3>
FSOUND_IT215</H3>
<PRE>
public static final int <B>FSOUND_IT215</B></PRE>
<DL>
<DD>For user created source data stored using IT215 compression.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_IT215">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_HW3D"><!-- --></A><H3>
FSOUND_HW3D</H3>
<PRE>
public static final int <B>FSOUND_HW3D</B></PRE>
<DL>
<DD>Attempts to make samples use 3d hardware acceleration. (if the card supports it)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_HW3D">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_2D"><!-- --></A><H3>
FSOUND_2D</H3>
<PRE>
public static final int <B>FSOUND_2D</B></PRE>
<DL>
<DD>Tells software (not hardware) based sample not to be included in 3d processing.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_2D">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_STREAMABLE"><!-- --></A><H3>
FSOUND_STREAMABLE</H3>
<PRE>
public static final int <B>FSOUND_STREAMABLE</B></PRE>
<DL>
<DD>For a streamimg sound where you feed the data to it.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_STREAMABLE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_LOADMEMORY"><!-- --></A><H3>
FSOUND_LOADMEMORY</H3>
<PRE>
public static final int <B>FSOUND_LOADMEMORY</B></PRE>
<DL>
<DD>"name" will be interpreted as a pointer to data for streaming and samples.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_LOADMEMORY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_LOADRAW"><!-- --></A><H3>
FSOUND_LOADRAW</H3>
<PRE>
public static final int <B>FSOUND_LOADRAW</B></PRE>
<DL>
<DD>Will ignore file format and treat as raw pcm.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_LOADRAW">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_MPEGACCURATE"><!-- --></A><H3>
FSOUND_MPEGACCURATE</H3>
<PRE>
public static final int <B>FSOUND_MPEGACCURATE</B></PRE>
<DL>
<DD>For FSOUND_Stream_Open - for accurate FSOUND_Stream_GetLengthMs/FSOUND_Stream_SetTime.  WARNING, see FSOUND_Stream_Open for inital opening time performance issues.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_MPEGACCURATE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_FORCEMONO"><!-- --></A><H3>
FSOUND_FORCEMONO</H3>
<PRE>
public static final int <B>FSOUND_FORCEMONO</B></PRE>
<DL>
<DD>For forcing stereo streams and samples to be mono - needed if using FSOUND_HW3D and stereo data - incurs a small speed hit for streams
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_FORCEMONO">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_HW2D"><!-- --></A><H3>
FSOUND_HW2D</H3>
<PRE>
public static final int <B>FSOUND_HW2D</B></PRE>
<DL>
<DD>2D hardware sounds.  allows hardware specific effects
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_HW2D">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_ENABLEFX"><!-- --></A><H3>
FSOUND_ENABLEFX</H3>
<PRE>
public static final int <B>FSOUND_ENABLEFX</B></PRE>
<DL>
<DD>Allows DX8 FX to be played back on a sound.  Requires DirectX 8 - Note these sounds cannot be played more than once, be 8 bit, be less than a certain size, or have a changing frequency
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_ENABLEFX">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_MPEGHALFRATE"><!-- --></A><H3>
FSOUND_MPEGHALFRATE</H3>
<PRE>
public static final int <B>FSOUND_MPEGHALFRATE</B></PRE>
<DL>
<DD>For FMODCE only - decodes mpeg streams using a lower quality decode, but faster execution
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_MPEGHALFRATE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_IMAADPCM"><!-- --></A><H3>
FSOUND_IMAADPCM</H3>
<PRE>
public static final int <B>FSOUND_IMAADPCM</B></PRE>
<DL>
<DD>Contents are stored compressed as IMA ADPCM
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_IMAADPCM">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_VAG"><!-- --></A><H3>
FSOUND_VAG</H3>
<PRE>
public static final int <B>FSOUND_VAG</B></PRE>
<DL>
<DD>For PS2 only - Contents are compressed as Sony VAG format
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_VAG">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_NONBLOCKING"><!-- --></A><H3>
FSOUND_NONBLOCKING</H3>
<PRE>
public static final int <B>FSOUND_NONBLOCKING</B></PRE>
<DL>
<DD>For FSOUND_Stream_Open/FMUSIC_LoadSong - Causes stream or music to open in the background and not block the foreground app.  See FSOUND_Stream_GetOpenState or FMUSIC_GetOpenState to determine when it IS ready.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_NONBLOCKING">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_GCADPCM"><!-- --></A><H3>
FSOUND_GCADPCM</H3>
<PRE>
public static final int <B>FSOUND_GCADPCM</B></PRE>
<DL>
<DD>For Gamecube only - Contents are compressed as Gamecube DSP-ADPCM format
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_GCADPCM">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_MULTICHANNEL"><!-- --></A><H3>
FSOUND_MULTICHANNEL</H3>
<PRE>
public static final int <B>FSOUND_MULTICHANNEL</B></PRE>
<DL>
<DD>For PS2 and Gamecube only - Contents are interleaved into a multi-channel (more than stereo) format
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_MULTICHANNEL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_USECORE0"><!-- --></A><H3>
FSOUND_USECORE0</H3>
<PRE>
public static final int <B>FSOUND_USECORE0</B></PRE>
<DL>
<DD>For PS2 only - Sample/Stream is forced to use hardware voices 00-23
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_USECORE0">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_USECORE1"><!-- --></A><H3>
FSOUND_USECORE1</H3>
<PRE>
public static final int <B>FSOUND_USECORE1</B></PRE>
<DL>
<DD>For PS2 only - Sample/Stream is forced to use hardware voices 24-47
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_USECORE1">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_LOADMEMORYIOP"><!-- --></A><H3>
FSOUND_LOADMEMORYIOP</H3>
<PRE>
public static final int <B>FSOUND_LOADMEMORYIOP</B></PRE>
<DL>
<DD>For PS2 only - "name" will be interpreted as a pointer to data for streaming and samples.  The address provided will be an IOP address
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_LOADMEMORYIOP">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_IGNORETAGS"><!-- --></A><H3>
FSOUND_IGNORETAGS</H3>
<PRE>
public static final int <B>FSOUND_IGNORETAGS</B></PRE>
<DL>
<DD>Skips id3v2 etc tag checks when opening a stream, to reduce seek/read overhead when opening files (helps with CD performance)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_IGNORETAGS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_STREAM_NET"><!-- --></A><H3>
FSOUND_STREAM_NET</H3>
<PRE>
public static final int <B>FSOUND_STREAM_NET</B></PRE>
<DL>
<DD>Specifies an internet stream
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_STREAM_NET">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_NORMAL"><!-- --></A><H3>
FSOUND_NORMAL</H3>
<PRE>
public static final int <B>FSOUND_NORMAL</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_NORMAL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_CD_PLAYCONTINUOUS"><!-- --></A><H3>
FSOUND_CD_PLAYCONTINUOUS</H3>
<PRE>
public static final int <B>FSOUND_CD_PLAYCONTINUOUS</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_CD_PLAYCONTINUOUS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_CD_PLAYONCE"><!-- --></A><H3>
FSOUND_CD_PLAYONCE</H3>
<PRE>
public static final int <B>FSOUND_CD_PLAYONCE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_CD_PLAYONCE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_CD_PLAYLOOPED"><!-- --></A><H3>
FSOUND_CD_PLAYLOOPED</H3>
<PRE>
public static final int <B>FSOUND_CD_PLAYLOOPED</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_CD_PLAYLOOPED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_CD_PLAYRANDOM"><!-- --></A><H3>
FSOUND_CD_PLAYRANDOM</H3>
<PRE>
public static final int <B>FSOUND_CD_PLAYRANDOM</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_CD_PLAYRANDOM">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_FREE"><!-- --></A><H3>
FSOUND_FREE</H3>
<PRE>
public static final int <B>FSOUND_FREE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_FREE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_UNMANAGED"><!-- --></A><H3>
FSOUND_UNMANAGED</H3>
<PRE>
public static final int <B>FSOUND_UNMANAGED</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_UNMANAGED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_ALL"><!-- --></A><H3>
FSOUND_ALL</H3>
<PRE>
public static final int <B>FSOUND_ALL</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_ALL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_STEREOPAN"><!-- --></A><H3>
FSOUND_STEREOPAN</H3>
<PRE>
public static final int <B>FSOUND_STEREOPAN</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_STEREOPAN">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_SYSTEMCHANNEL"><!-- --></A><H3>
FSOUND_SYSTEMCHANNEL</H3>
<PRE>
public static final int <B>FSOUND_SYSTEMCHANNEL</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_SYSTEMCHANNEL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_SYSTEMSAMPLE"><!-- --></A><H3>
FSOUND_SYSTEMSAMPLE</H3>
<PRE>
public static final int <B>FSOUND_SYSTEMSAMPLE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_SYSTEMSAMPLE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_REVERB_FLAGS_DECAYTIMESCALE"><!-- --></A><H3>
FSOUND_REVERB_FLAGS_DECAYTIMESCALE</H3>
<PRE>
public static final int <B>FSOUND_REVERB_FLAGS_DECAYTIMESCALE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_REVERB_FLAGS_DECAYTIMESCALE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_REVERB_FLAGS_REFLECTIONSSCALE"><!-- --></A><H3>
FSOUND_REVERB_FLAGS_REFLECTIONSSCALE</H3>
<PRE>
public static final int <B>FSOUND_REVERB_FLAGS_REFLECTIONSSCALE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_REVERB_FLAGS_REFLECTIONSSCALE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_REVERB_FLAGS_REFLECTIONSDELAYSCALE"><!-- --></A><H3>
FSOUND_REVERB_FLAGS_REFLECTIONSDELAYSCALE</H3>
<PRE>
public static final int <B>FSOUND_REVERB_FLAGS_REFLECTIONSDELAYSCALE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_REVERB_FLAGS_REFLECTIONSDELAYSCALE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_REVERB_FLAGS_REVERBSCALE"><!-- --></A><H3>
FSOUND_REVERB_FLAGS_REVERBSCALE</H3>
<PRE>
public static final int <B>FSOUND_REVERB_FLAGS_REVERBSCALE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_REVERB_FLAGS_REVERBSCALE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_REVERB_FLAGS_REVERBDELAYSCALE"><!-- --></A><H3>
FSOUND_REVERB_FLAGS_REVERBDELAYSCALE</H3>
<PRE>
public static final int <B>FSOUND_REVERB_FLAGS_REVERBDELAYSCALE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_REVERB_FLAGS_REVERBDELAYSCALE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_REVERB_FLAGS_DECAYHFLIMIT"><!-- --></A><H3>
FSOUND_REVERB_FLAGS_DECAYHFLIMIT</H3>
<PRE>
public static final int <B>FSOUND_REVERB_FLAGS_DECAYHFLIMIT</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_REVERB_FLAGS_DECAYHFLIMIT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_REVERB_FLAGS_ECHOTIMESCALE"><!-- --></A><H3>
FSOUND_REVERB_FLAGS_ECHOTIMESCALE</H3>
<PRE>
public static final int <B>FSOUND_REVERB_FLAGS_ECHOTIMESCALE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_REVERB_FLAGS_ECHOTIMESCALE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_REVERB_FLAGS_MODULATIONTIMESCALE"><!-- --></A><H3>
FSOUND_REVERB_FLAGS_MODULATIONTIMESCALE</H3>
<PRE>
public static final int <B>FSOUND_REVERB_FLAGS_MODULATIONTIMESCALE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_REVERB_FLAGS_MODULATIONTIMESCALE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_REVERB_FLAGS_CORE0"><!-- --></A><H3>
FSOUND_REVERB_FLAGS_CORE0</H3>
<PRE>
public static final int <B>FSOUND_REVERB_FLAGS_CORE0</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_REVERB_FLAGS_CORE0">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_REVERB_FLAGS_CORE1"><!-- --></A><H3>
FSOUND_REVERB_FLAGS_CORE1</H3>
<PRE>
public static final int <B>FSOUND_REVERB_FLAGS_CORE1</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_REVERB_FLAGS_CORE1">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_REVERB_FLAGS_DEFAULT"><!-- --></A><H3>
FSOUND_REVERB_FLAGS_DEFAULT</H3>
<PRE>
public static final int <B>FSOUND_REVERB_FLAGS_DEFAULT</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_REVERB_FLAGS_DEFAULT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_TAGFIELD_VORBISCOMMENT"><!-- --></A><H3>
FSOUND_TAGFIELD_VORBISCOMMENT</H3>
<PRE>
public static final int <B>FSOUND_TAGFIELD_VORBISCOMMENT</B></PRE>
<DL>
<DD>A vorbis comment
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_TAGFIELD_VORBISCOMMENT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_TAGFIELD_ID3V1"><!-- --></A><H3>
FSOUND_TAGFIELD_ID3V1</H3>
<PRE>
public static final int <B>FSOUND_TAGFIELD_ID3V1</B></PRE>
<DL>
<DD>Part of an ID3v1 tag
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_TAGFIELD_ID3V1">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_TAGFIELD_ID3V2"><!-- --></A><H3>
FSOUND_TAGFIELD_ID3V2</H3>
<PRE>
public static final int <B>FSOUND_TAGFIELD_ID3V2</B></PRE>
<DL>
<DD>An ID3v2 frame
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_TAGFIELD_ID3V2">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_TAGFIELD_SHOUTCAST"><!-- --></A><H3>
FSOUND_TAGFIELD_SHOUTCAST</H3>
<PRE>
public static final int <B>FSOUND_TAGFIELD_SHOUTCAST</B></PRE>
<DL>
<DD>A SHOUTcast header line
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_TAGFIELD_SHOUTCAST">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_TAGFIELD_ICECAST"><!-- --></A><H3>
FSOUND_TAGFIELD_ICECAST</H3>
<PRE>
public static final int <B>FSOUND_TAGFIELD_ICECAST</B></PRE>
<DL>
<DD>An Icecast header line
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_TAGFIELD_ICECAST">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_TAGFIELD_ASF"><!-- --></A><H3>
FSOUND_TAGFIELD_ASF</H3>
<PRE>
public static final int <B>FSOUND_TAGFIELD_ASF</B></PRE>
<DL>
<DD>An Advanced Streaming Format header line
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_TAGFIELD_ASF">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_STREAM_NET_NOTCONNECTED"><!-- --></A><H3>
FSOUND_STREAM_NET_NOTCONNECTED</H3>
<PRE>
public static final int <B>FSOUND_STREAM_NET_NOTCONNECTED</B></PRE>
<DL>
<DD>Stream hasn't connected yet
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_STREAM_NET_NOTCONNECTED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_STREAM_NET_CONNECTING"><!-- --></A><H3>
FSOUND_STREAM_NET_CONNECTING</H3>
<PRE>
public static final int <B>FSOUND_STREAM_NET_CONNECTING</B></PRE>
<DL>
<DD>Stream is connecting to remote host
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_STREAM_NET_CONNECTING">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_STREAM_NET_BUFFERING"><!-- --></A><H3>
FSOUND_STREAM_NET_BUFFERING</H3>
<PRE>
public static final int <B>FSOUND_STREAM_NET_BUFFERING</B></PRE>
<DL>
<DD>Stream is buffering data
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_STREAM_NET_BUFFERING">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_STREAM_NET_READY"><!-- --></A><H3>
FSOUND_STREAM_NET_READY</H3>
<PRE>
public static final int <B>FSOUND_STREAM_NET_READY</B></PRE>
<DL>
<DD>Stream is ready to play
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_STREAM_NET_READY">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_STREAM_NET_ERROR"><!-- --></A><H3>
FSOUND_STREAM_NET_ERROR</H3>
<PRE>
public static final int <B>FSOUND_STREAM_NET_ERROR</B></PRE>
<DL>
<DD>Stream has suffered a fatal error
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_STREAM_NET_ERROR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_FX_CHORUS"><!-- --></A><H3>
FSOUND_FX_CHORUS</H3>
<PRE>
public static final int <B>FSOUND_FX_CHORUS</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_FX_CHORUS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_FX_COMPRESSOR"><!-- --></A><H3>
FSOUND_FX_COMPRESSOR</H3>
<PRE>
public static final int <B>FSOUND_FX_COMPRESSOR</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_FX_COMPRESSOR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_FX_DISTORTION"><!-- --></A><H3>
FSOUND_FX_DISTORTION</H3>
<PRE>
public static final int <B>FSOUND_FX_DISTORTION</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_FX_DISTORTION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_FX_ECHO"><!-- --></A><H3>
FSOUND_FX_ECHO</H3>
<PRE>
public static final int <B>FSOUND_FX_ECHO</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_FX_ECHO">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_FX_FLANGER"><!-- --></A><H3>
FSOUND_FX_FLANGER</H3>
<PRE>
public static final int <B>FSOUND_FX_FLANGER</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_FX_FLANGER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_FX_GARGLE"><!-- --></A><H3>
FSOUND_FX_GARGLE</H3>
<PRE>
public static final int <B>FSOUND_FX_GARGLE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_FX_GARGLE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_FX_I3DL2REVERB"><!-- --></A><H3>
FSOUND_FX_I3DL2REVERB</H3>
<PRE>
public static final int <B>FSOUND_FX_I3DL2REVERB</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_FX_I3DL2REVERB">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_FX_PARAMEQ"><!-- --></A><H3>
FSOUND_FX_PARAMEQ</H3>
<PRE>
public static final int <B>FSOUND_FX_PARAMEQ</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_FX_PARAMEQ">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_FX_WAVES_REVERB"><!-- --></A><H3>
FSOUND_FX_WAVES_REVERB</H3>
<PRE>
public static final int <B>FSOUND_FX_WAVES_REVERB</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_FX_WAVES_REVERB">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_FX_MAX"><!-- --></A><H3>
FSOUND_FX_MAX</H3>
<PRE>
public static final int <B>FSOUND_FX_MAX</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_FX_MAX">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_SPEAKERMODE_DOLBYDIGITAL"><!-- --></A><H3>
FSOUND_SPEAKERMODE_DOLBYDIGITAL</H3>
<PRE>
public static final int <B>FSOUND_SPEAKERMODE_DOLBYDIGITAL</B></PRE>
<DL>
<DD>Dolby Digital Output (XBOX or PC only).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_SPEAKERMODE_DOLBYDIGITAL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_SPEAKERMODE_HEADPHONES"><!-- --></A><H3>
FSOUND_SPEAKERMODE_HEADPHONES</H3>
<PRE>
public static final int <B>FSOUND_SPEAKERMODE_HEADPHONES</B></PRE>
<DL>
<DD>The speakers are headphones.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_SPEAKERMODE_HEADPHONES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_SPEAKERMODE_MONO"><!-- --></A><H3>
FSOUND_SPEAKERMODE_MONO</H3>
<PRE>
public static final int <B>FSOUND_SPEAKERMODE_MONO</B></PRE>
<DL>
<DD>The speakers are monaural.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_SPEAKERMODE_MONO">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_SPEAKERMODE_QUAD"><!-- --></A><H3>
FSOUND_SPEAKERMODE_QUAD</H3>
<PRE>
public static final int <B>FSOUND_SPEAKERMODE_QUAD</B></PRE>
<DL>
<DD>The speakers are quadraphonic.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_SPEAKERMODE_QUAD">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_SPEAKERMODE_STEREO"><!-- --></A><H3>
FSOUND_SPEAKERMODE_STEREO</H3>
<PRE>
public static final int <B>FSOUND_SPEAKERMODE_STEREO</B></PRE>
<DL>
<DD>The speakers are stereo (default value).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_SPEAKERMODE_STEREO">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_SPEAKERMODE_SURROUND"><!-- --></A><H3>
FSOUND_SPEAKERMODE_SURROUND</H3>
<PRE>
public static final int <B>FSOUND_SPEAKERMODE_SURROUND</B></PRE>
<DL>
<DD>The speakers are surround sound.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_SPEAKERMODE_SURROUND">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_SPEAKERMODE_DTS"><!-- --></A><H3>
FSOUND_SPEAKERMODE_DTS</H3>
<PRE>
public static final int <B>FSOUND_SPEAKERMODE_DTS</B></PRE>
<DL>
<DD>DTS output (XBOX only).
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_SPEAKERMODE_DTS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_SPEAKERMODE_PROLOGIC2"><!-- --></A><H3>
FSOUND_SPEAKERMODE_PROLOGIC2</H3>
<PRE>
public static final int <B>FSOUND_SPEAKERMODE_PROLOGIC2</B></PRE>
<DL>
<DD>Dolby Prologic 2.  Playstation 2 and Gamecube only.  PlayStation 2 doesnt support interior panning, but supports 48 voices simultaneously.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_SPEAKERMODE_PROLOGIC2">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_SPEAKERMODE_PROLOGIC2_INTERIOR"><!-- --></A><H3>
FSOUND_SPEAKERMODE_PROLOGIC2_INTERIOR</H3>
<PRE>
public static final int <B>FSOUND_SPEAKERMODE_PROLOGIC2_INTERIOR</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_SPEAKERMODE_PROLOGIC2_INTERIOR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_INIT_USEDEFAULTMIDISYNTH"><!-- --></A><H3>
FSOUND_INIT_USEDEFAULTMIDISYNTH</H3>
<PRE>
public static final int <B>FSOUND_INIT_USEDEFAULTMIDISYNTH</B></PRE>
<DL>
<DD>Win32 only - Causes MIDI playback to force software decoding.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_INIT_USEDEFAULTMIDISYNTH">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_INIT_GLOBALFOCUS"><!-- --></A><H3>
FSOUND_INIT_GLOBALFOCUS</H3>
<PRE>
public static final int <B>FSOUND_INIT_GLOBALFOCUS</B></PRE>
<DL>
<DD>Win32 only - For DirectSound output - sound is not muted when window is out of focus.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_INIT_GLOBALFOCUS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_INIT_ENABLESYSTEMCHANNELFX"><!-- --></A><H3>
FSOUND_INIT_ENABLESYSTEMCHANNELFX</H3>
<PRE>
public static final int <B>FSOUND_INIT_ENABLESYSTEMCHANNELFX</B></PRE>
<DL>
<DD>Win32 only - For DirectSound output - Allows FSOUND_FX api to be used on global software mixer output! (use FSOUND_SYSTEMCHANNEL as channel id)
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_INIT_ENABLESYSTEMCHANNELFX">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_INIT_ACCURATEVULEVELS"><!-- --></A><H3>
FSOUND_INIT_ACCURATEVULEVELS</H3>
<PRE>
public static final int <B>FSOUND_INIT_ACCURATEVULEVELS</B></PRE>
<DL>
<DD>This latency adjusts FSOUND_GetCurrentLevels, but incurs a small cpu and memory hit
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_INIT_ACCURATEVULEVELS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_INIT_PS2_DISABLECORE0REVERB"><!-- --></A><H3>
FSOUND_INIT_PS2_DISABLECORE0REVERB</H3>
<PRE>
public static final int <B>FSOUND_INIT_PS2_DISABLECORE0REVERB</B></PRE>
<DL>
<DD>PS2 only   - Disable reverb on CORE 0 to regain SRAM
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_INIT_PS2_DISABLECORE0REVERB">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_INIT_PS2_DISABLECORE1REVERB"><!-- --></A><H3>
FSOUND_INIT_PS2_DISABLECORE1REVERB</H3>
<PRE>
public static final int <B>FSOUND_INIT_PS2_DISABLECORE1REVERB</B></PRE>
<DL>
<DD>PS2 only   - Disable reverb on CORE 1 to regain SRAM
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_INIT_PS2_DISABLECORE1REVERB">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_INIT_PS2_SWAPDMACORES"><!-- --></A><H3>
FSOUND_INIT_PS2_SWAPDMACORES</H3>
<PRE>
public static final int <B>FSOUND_INIT_PS2_SWAPDMACORES</B></PRE>
<DL>
<DD>PS2 only   - By default FMOD uses DMA CH0 for mixing, CH1 for uploads, this flag swaps them around
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_INIT_PS2_SWAPDMACORES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_INIT_DONTLATENCYADJUST"><!-- --></A><H3>
FSOUND_INIT_DONTLATENCYADJUST</H3>
<PRE>
public static final int <B>FSOUND_INIT_DONTLATENCYADJUST</B></PRE>
<DL>
<DD>Callbacks are not latency adjusted, and are called at mix time.  Also information functions are immediate
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_INIT_DONTLATENCYADJUST">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_INIT_GC_INITLIBS"><!-- --></A><H3>
FSOUND_INIT_GC_INITLIBS</H3>
<PRE>
public static final int <B>FSOUND_INIT_GC_INITLIBS</B></PRE>
<DL>
<DD>GC only    - Initializes GC audio libraries
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_INIT_GC_INITLIBS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_INIT_STREAM_FROM_MAIN_THREAD"><!-- --></A><H3>
FSOUND_INIT_STREAM_FROM_MAIN_THREAD</H3>
<PRE>
public static final int <B>FSOUND_INIT_STREAM_FROM_MAIN_THREAD</B></PRE>
<DL>
<DD>Turns off fmod streamer thread, and makes streaming update from FSOUND_Update called by the user
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_INIT_STREAM_FROM_MAIN_THREAD">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_INIT_PS2_USEVOLUMERAMPING"><!-- --></A><H3>
FSOUND_INIT_PS2_USEVOLUMERAMPING</H3>
<PRE>
public static final int <B>FSOUND_INIT_PS2_USEVOLUMERAMPING</B></PRE>
<DL>
<DD>PS2 only   - Turns on volume ramping system to remove hardware clicks.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_INIT_PS2_USEVOLUMERAMPING">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_INIT_DSOUND_DEFERRED"><!-- --></A><H3>
FSOUND_INIT_DSOUND_DEFERRED</H3>
<PRE>
public static final int <B>FSOUND_INIT_DSOUND_DEFERRED</B></PRE>
<DL>
<DD>Win32 only - For DirectSound output.  3D commands are batched together and executed at FSOUND_Update.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_INIT_DSOUND_DEFERRED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_INIT_DSOUND_HRTF_LIGHT"><!-- --></A><H3>
FSOUND_INIT_DSOUND_HRTF_LIGHT</H3>
<PRE>
public static final int <B>FSOUND_INIT_DSOUND_HRTF_LIGHT</B></PRE>
<DL>
<DD>Win32 only - For DirectSound output.  FSOUND_HW3D buffers use a slightly higher quality algorithm when 3d hardware acceleration is not present.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_INIT_DSOUND_HRTF_LIGHT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_INIT_DSOUND_HRTF_FULL"><!-- --></A><H3>
FSOUND_INIT_DSOUND_HRTF_FULL</H3>
<PRE>
public static final int <B>FSOUND_INIT_DSOUND_HRTF_FULL</B></PRE>
<DL>
<DD>Win32 only - For DirectSound output.  FSOUND_HW3D buffers use full quality 3d playback when 3d hardware acceleration is not present.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_INIT_DSOUND_HRTF_FULL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_PROTOCOL_SHOUTCAST"><!-- --></A><H3>
FSOUND_PROTOCOL_SHOUTCAST</H3>
<PRE>
public static final int <B>FSOUND_PROTOCOL_SHOUTCAST</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_PROTOCOL_SHOUTCAST">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_PROTOCOL_ICECAST"><!-- --></A><H3>
FSOUND_PROTOCOL_ICECAST</H3>
<PRE>
public static final int <B>FSOUND_PROTOCOL_ICECAST</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_PROTOCOL_ICECAST">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_PROTOCOL_HTTP"><!-- --></A><H3>
FSOUND_PROTOCOL_HTTP</H3>
<PRE>
public static final int <B>FSOUND_PROTOCOL_HTTP</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_PROTOCOL_HTTP">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_FORMAT_MPEG"><!-- --></A><H3>
FSOUND_FORMAT_MPEG</H3>
<PRE>
public static final int <B>FSOUND_FORMAT_MPEG</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_FORMAT_MPEG">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FSOUND_FORMAT_OGGVORBIS"><!-- --></A><H3>
FSOUND_FORMAT_OGGVORBIS</H3>
<PRE>
public static final int <B>FSOUND_FORMAT_OGGVORBIS</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#org.lwjgl.fmod3.FSound.FSOUND_FORMAT_OGGVORBIS">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="FSound()"><!-- --></A><H3>
FSound</H3>
<PRE>
public <B>FSound</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="FSOUND_Close()"><!-- --></A><H3>
FSOUND_Close</H3>
<PRE>
public static void <B>FSOUND_Close</B>()</PRE>
<DL>
<DD>Shuts down the WHOLE FMOD Sound System
 <p>
 <b>Remarks</b>
 This also closes down the sample management system, freeing all MANAGED samples loaded (unless they were allocated with the FSOUND_UNMANAGED flag).
 Streams are not freed. You must close them yourself.
 CD Tracks are stopped.
 </p>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_File_SetCallbacks(org.lwjgl.fmod3.callbacks.FSoundOpenCallback, org.lwjgl.fmod3.callbacks.FSoundCloseCallback, org.lwjgl.fmod3.callbacks.FSoundReadCallback, org.lwjgl.fmod3.callbacks.FSoundSeekCallback, org.lwjgl.fmod3.callbacks.FSoundTellCallback)"><!-- --></A><H3>
FSOUND_File_SetCallbacks</H3>
<PRE>
public static void <B>FSOUND_File_SetCallbacks</B>(<A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundOpenCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundOpenCallback</A>&nbsp;open,
                                            <A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundCloseCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundCloseCallback</A>&nbsp;close,
                                            <A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundReadCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundReadCallback</A>&nbsp;read,
                                            <A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundSeekCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundSeekCallback</A>&nbsp;seek,
                                            <A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundTellCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundTellCallback</A>&nbsp;tell)</PRE>
<DL>
<DD>Specify user callbacks for FMOD's internal file manipulation functions.
 If ANY of these parameters are NULL, then FMOD will switch back to its own file routines.
 You can replace this with memory routines (ie name can be cast to a memory address for example, then open sets up
 a handle based on this information), or alternate file routines, ie a WAD file reader.
 <p>
 <b>Remarks</b>
 Memory loader FMOD functions are not affected, such as FMUSIC_LoadSongMemory etc.
 WARNING : This function is dangerous in the wrong hands. You must return the right values, and each command must work properly, or FMOD will not function, or it may even crash if you give it invalid data.
 You must support SEEK_SET, SEEK_CUR and SEEK_END properly, or FMOD will not work properly. See standard I/O help files on how these work under fseek().
 Read the documentation in REMARKS and do exactly what it says. See the "simple" example for how it is used properly.
 The MIDI loader does not support user file callbacks. For WAD type data structures with embedded MIDI files FMUSIC_LoadSongMemory will have to be used.
 --------------
 PlayStation 2 NOTE! This function takes IOP function pointers, not EE pointers! It is for custom IOP file systems not EE based ones.
 This function can only be called after FSOUND_Init on PlayStation 2, not before
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>open</CODE> - Open callback<DD><CODE>close</CODE> - Close callback<DD><CODE>read</CODE> - Read callback<DD><CODE>seek</CODE> - Seek callback<DD><CODE>tell</CODE> - Tell callback</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Init(int, int, int)"><!-- --></A><H3>
FSOUND_Init</H3>
<PRE>
public static boolean <B>FSOUND_Init</B>(int&nbsp;mixrate,
                                  int&nbsp;channels,
                                  int&nbsp;flags)</PRE>
<DL>
<DD>Initializes the FMOD Sound System.
 <p>
 <b>Remarks</b>
 You do not have control over how many hardware channels are available to you. In a lot of
 cases it may be 0 (the sound card does not have the ability to supply hardware channels).
 This is why it is usually a good idea to supply FSOUND_Init with a good number of software
 channels to fall back onto, for example 32.
 Hardware channels are 3D hardware channels only. There is no benefit in supporting hardware
 for 2d playback of sound effects. With todays machines and FMOD's superior mixing routines,
 FMOD's software engine can sometimes be faster than the driver's hardware support!
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mixrate</CODE> - Output rate in hz between 4000 and 65535. Any thing outside this will cause
 the function to fail and return false.
 PS2 Note. Only rates of 24000 and 48000 are supported.
 SmartPhone Note. Use 22050 or the operating system may crash outside of the control of fmod.<DD><CODE>channels</CODE> - Maximum number of SOFTWARE channels available.
 The number of HARDWARE channels is autodetected. The total number of channels available (hardware and software) after initialization can be found with FSOUND_GetMaxChannels. 
 Having a large number of maxchannels does not adversely affect cpu usage, but it means it has the POTENTIAL to mix a large number of channels, which can have an adverse effect on cpu usage.
 1024 is the highest number that can be set. Anything higher will return an error.<DD><CODE>flags</CODE> - See FSOUND_INIT_FLAGS. Controls some global or initialization time aspects of playback
<DT><B>Returns:</B><DD>On success, true is returned. On failure, false is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetBufferSize(int)"><!-- --></A><H3>
FSOUND_SetBufferSize</H3>
<PRE>
public static boolean <B>FSOUND_SetBufferSize</B>(int&nbsp;len_ms)</PRE>
<DL>
<DD>Sets the FMOD internal mixing buffer size. 
 It is configurable because low buffersizes use less memory, but are more instable.
 More importantly, increasing buffer size will increase sound output stability, but
 on the other hand increases latency, and to some extent, CPU usage.
 FMOD chooses the most optimal size by default for best stability, depending on the
 output type - and if the drivers are emulated or not (NT). 
 It is not recommended changing this value unless you really need to. You may get worse 
 performance than the default settings chosen by FMOD.
 <p>
 <b>Remarks</b>
 This function cannot be called after FMOD is already activated with FSOUND_Init.
 It must be called before FSOUND_Init, or after FSOUND_Close.
 ---------
 The buffersize seting defaults to 50ms if it is not called for DSOUND. 
 It defaults to 200ms for Windows Multimedia wave-out or for emulated DirectSound drivers (such as NT drivers).
 When the output is FSOUND_OUTPUT_ASIO the buffersize is ignored. The buffersize should be configured using the ASIO driver which can be done with the supplied asioconfig.exe in the FMOD SDK.
 ---------
 Buffer sizes lower than 50 are clamped at 50.
 Buffer sizes are also rounded DOWN to the nearest multiple of 25. This is because FMOD mixes in blocks of 25ms.
 Due to this buffersize command latency on software channels will be between 25 and 50ms on average (37.5ms) when the buffersize is set to 50.
 ---------
 Macintosh, PlayStation 2 and GameCube do not support this as they already achieve minimal latency and are forced to 25ms.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>len_ms</CODE> - buffer size in milliseconds.
<DT><B>Returns:</B><DD>On success, true is returned. On failure, (ie if FMOD is already active) false is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetDriver(int)"><!-- --></A><H3>
FSOUND_SetDriver</H3>
<PRE>
public static boolean <B>FSOUND_SetDriver</B>(int&nbsp;driver)</PRE>
<DL>
<DD>Selects a soundcard driver.
 It is used when an output mode has enumerated more than one output device, and you need to select between them.
 <p>
 <b>Remarks</b>
 This function cannot be called after FMOD is already activated with FSOUND_Init.
 It must be called before FSOUND_Init, or after FSOUND_Close.   
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>driver</CODE> - Driver number to select. 0 will select the DEFAULT sound driver. 
 &gt;0 will select an INVALID driver which will case the DEVICE to be set 
 to a null (nosound) driver.
 &lt;0 Selects other valid drivers that can be listed with FSOUND_GetDriverName.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, (ie if FMOD is already active) FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetMaxHardwareChannels(int)"><!-- --></A><H3>
FSOUND_SetMaxHardwareChannels</H3>
<PRE>
public static boolean <B>FSOUND_SetMaxHardwareChannels</B>(int&nbsp;max)</PRE>
<DL>
<DD>This sets the maximum allocatable channels on a hardware card. FMOD automatically 
 detects and allocates the maximum number of 3d hardware channels, so calling this 
 will limit that number if it becomes too much
 <p>
 <b>Remarks</b>
 This function cannot be called after FMOD is already activated with FSOUND_Init.
 It must be called before FSOUND_Init, or after FSOUND_Close.
 ---------
 This function has nothing to do with FSOUND_SetMinHardwareChannels, in that this is not a function that forces FMOD into software mixing if a card has a certain number of channels.
 This function only sets a limit on hardware channels, so if you card has 96 hardware channels, and you set FSOUND_SetMaxHardwareChannels(10), then you will only have 10 hardware channels to use.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>max</CODE> - maximum number of hardware channels to allocate, even if the soundcard supports more
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetMinHardwareChannels(int)"><!-- --></A><H3>
FSOUND_SetMinHardwareChannels</H3>
<PRE>
public static boolean <B>FSOUND_SetMinHardwareChannels</B>(int&nbsp;min)</PRE>
<DL>
<DD>This sets the minimum allowable hardware channels before FMOD drops back to 100 percent software.
 This is helpful for minimum spec cards, and not having to guess how many hardware channels
 they might have. This way you can guarantee and assume a certain number of channels for
 your application and place them all in FSOUND_HW3D without fear of the playsound failing
 because it runs out of channels on a low spec card.
 <p>
 <b>Remarks</b>
 As an example, if you set your minimum to 16, you can now safely guarantee that 16 sounds can be played at once that are created with FSOUND_HW3D. 
 This way if you do come across a card that only supports 4 channels, it will just drop back to playing ALL sounds in software mode. 
 It may sound worse, but at least it doesnt fail on the playsound. (which could sound even worse!)   
 ---------
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>min</CODE> - minimum number of hardware channels allowable on a card before it uses the software engine 1004562604f the time
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetMixer(int)"><!-- --></A><H3>
FSOUND_SetMixer</H3>
<PRE>
public static boolean <B>FSOUND_SetMixer</B>(int&nbsp;mixer)</PRE>
<DL>
<DD>Sets a digital mixer type.
 <p>
 <b>Remarks</b>
 This function cannot be called after FMOD is already activated with FSOUND_Init.
 It must be called before FSOUND_Init, or after FSOUND_Close.
 This function does not nescessarily need to be called, autodetection will select the 
 fastest mixer for your machine. It is here if you need to test all mixer types for 
 debugging purposes, or a mixer has a feature that the autodetected one doesnt.
 (ie low quality mixers or volume ramping)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mixer</CODE> - mixer type, see FSOUND_MIXERTYPES for valid parameters and descriptions
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, (ie if FMOD is already active) FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetOutput(int)"><!-- --></A><H3>
FSOUND_SetOutput</H3>
<PRE>
public static boolean <B>FSOUND_SetOutput</B>(int&nbsp;output)</PRE>
<DL>
<DD>Sets up the soundsystem output mode
 <p>
 <b>Remarks</b>
 This function cannot be called after FMOD is already activated with FSOUND_Init.
 It must be called before FSOUND_Init, or after FSOUND_Close.
 -------
 Under Windows NT - Waveout is FASTER than DirectSound, achieves LOWER latency, AND
 is LESS buggy. DirectSound under NT is achieved by emulating waveout, and therefore is
 inferior to waveout. Use WAVEOUT under NT.
 Under Windows 9x and W2K - DirectSound is faster than waveout and can achieve lower latency.
 Use DIRECTSOUND under Win9x and W2K.
 -------
 If you dont call FSOUND_SetOutput, FMOD will now autodetect DSOUND or WINMM based on the operating system.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>output</CODE> - The output system to be used. See FSOUND_OUTPUTTYPES for valid parameters and descriptions. -1 Is autodetect based on operating system
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, (ie if FMOD is already active) FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetPanSeperation(float)"><!-- --></A><H3>
FSOUND_SetPanSeperation</H3>
<PRE>
public static void <B>FSOUND_SetPanSeperation</B>(float&nbsp;pansep)</PRE>
<DL>
<DD>Sets the master pan seperation for 2d sound effects
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pansep</CODE> - The pan scalar. 1.0 means full pan seperation, 0 means mono</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetSFXMasterVolume(int)"><!-- --></A><H3>
FSOUND_SetSFXMasterVolume</H3>
<PRE>
public static void <B>FSOUND_SetSFXMasterVolume</B>(int&nbsp;volume)</PRE>
<DL>
<DD>Sets the master volume for any sound effects played. Does not affect music or CD output.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>volume</CODE> - The volume to set. Valid ranges are from 0 (silent) to 255 (full volume)</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetSpeakerMode(int)"><!-- --></A><H3>
FSOUND_SetSpeakerMode</H3>
<PRE>
public static void <B>FSOUND_SetSpeakerMode</B>(int&nbsp;speakermode)</PRE>
<DL>
<DD>Sets the mode for the users speaker setup
 <p>
 <b>Remarks</b>
 Note - Only reliably works with FSOUND_OUTPUT_DSOUND or FSOUND_OUTPUT_XBOX output modes. Other output modes will only interpret FSOUND_SPEAKERMODE_MONO and set everything else to be stereo.
 ----------------------------------
 To get true 5.1 dolby digital or DTS output you will need a soundcard that can encode it, and a receiver that can decode it. 
 If not the results can be unpredictable.
 ----------------------------------
 Calling this will reset the pan separation setting. It sets it to 0 if FSOUND_SPEAKERMODE_MONO is chosen, and 1 otherwise. 
 You will need to reset the pan separation if required afterwards.
 Note that some soundcard drivers may ignore this call.
 ----------------------------------
 XBOX only - This function MUST be called before FSOUND_Init to change the default speaker mode. To change on the fly, you must close down FMOD with FSOUND_Close then re-initialize it with FSOUND_Init.
 If it is called after FSOUND_Init, only headphone speakermode is interpreted to switch headphone mode on and off.
 ----------------------------------
 PlayStation 2 only - This function must be called before playing sounds. Calling this after playing a sound will not make that existing sound work in Prologic 2.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>speakermode</CODE> - enum describing the users speaker setup</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Update()"><!-- --></A><H3>
FSOUND_Update</H3>
<PRE>
public static void <B>FSOUND_Update</B>()</PRE>
<DL>
<DD>This updates the 3d sound engine and DMA engine (only on some platforms), and should be called once a game frame.
 This function will also update the software mixer if you have selected FSOUND_OUTPUT_NOSOUND_NONREALTIME as your output mode
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetCPUUsage()"><!-- --></A><H3>
FSOUND_GetCPUUsage</H3>
<PRE>
public static float <B>FSOUND_GetCPUUsage</B>()</PRE>
<DL>
<DD>Returns in percent of cpu time the amount of cpu usage that FSOUND/FMUSIC mixing is taking
 <p>
 <b>Remarks</b>
 This value represents the cpu usage used by streams, the software mixer, and subsequent calls to dsound waveout etc.
 MIDI playback is not counted as it is performed by directx.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>percent of cpu time the amount of cpu usage that FSOUND/FMUSIC mixing is taking</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetChannelsPlaying()"><!-- --></A><H3>
FSOUND_GetChannelsPlaying</H3>
<PRE>
public static int <B>FSOUND_GetChannelsPlaying</B>()</PRE>
<DL>
<DD>Returns the number of active channels in FSOUND, or ones that are playing
<P>
<DD><DL>

<DT><B>Returns:</B><DD>number of active channels in FSOUND, or ones that are playing</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetDriver()"><!-- --></A><H3>
FSOUND_GetDriver</H3>
<PRE>
public static int <B>FSOUND_GetDriver</B>()</PRE>
<DL>
<DD>Returns the currently selected driver number. Drivers are enumerated when selecting a driver 
 with FSOUND_SetDriver or other driver related functions such as FSOUND_GetNumDrivers or 
 FSOUND_GetDriverName
<P>
<DD><DL>

<DT><B>Returns:</B><DD>currently selected driver number.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetDriverCaps(int, java.nio.IntBuffer)"><!-- --></A><H3>
FSOUND_GetDriverCaps</H3>
<PRE>
public static boolean <B>FSOUND_GetDriverCaps</B>(int&nbsp;driverid,
                                           java.nio.IntBuffer&nbsp;caps)</PRE>
<DL>
<DD>Returns information on capabilities of the current output mode
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>driverid</CODE> - Enumerated driver ID. This must be in a valid range delimited by FSOUND_GetNumDrivers<DD><CODE>caps</CODE> - IntBuffer to have the caps bits stored
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetDriverName(int)"><!-- --></A><H3>
FSOUND_GetDriverName</H3>
<PRE>
public static java.lang.String <B>FSOUND_GetDriverName</B>(int&nbsp;driverid)</PRE>
<DL>
<DD>Returns the name of the selected driver. Drivers are enumerated when selecting a driver with
 FSOUND_SetDriver or other driver related functions such as FSOUND_GetNumDrivers or 
 FSOUND_GetDriver
 <p>
 <b>Remarks</b>
 If no driver is selected, the default driver is used.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>driverid</CODE> - Enumerated driver ID. This must be in a valid range delimited by FSOUND_GetNumDrivers
<DT><B>Returns:</B><DD>On success, a String containing the name of the specified device is returned. 
 The number of drivers enumerated can be found with FSOUND_GetNumDrivers. On failure, NULL is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetError()"><!-- --></A><H3>
FSOUND_GetError</H3>
<PRE>
public static int <B>FSOUND_GetError</B>()</PRE>
<DL>
<DD>Returns an error code set by FMOD
<P>
<DD><DL>

<DT><B>Returns:</B><DD>error code, see FMOD_ERRORS</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetMaxSamples()"><!-- --></A><H3>
FSOUND_GetMaxSamples</H3>
<PRE>
public static int <B>FSOUND_GetMaxSamples</B>()</PRE>
<DL>
<DD>Returns the current maximum index for a sample. This figure grows as you allocate more
 samples (in blocks)
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Maximum sample index</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetMaxChannels()"><!-- --></A><H3>
FSOUND_GetMaxChannels</H3>
<PRE>
public static int <B>FSOUND_GetMaxChannels</B>()</PRE>
<DL>
<DD>Returns the total number of channels allocated
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Number of channels allocated</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetMemoryStats(java.nio.IntBuffer)"><!-- --></A><H3>
FSOUND_GetMemoryStats</H3>
<PRE>
public static void <B>FSOUND_GetMemoryStats</B>(java.nio.IntBuffer&nbsp;currentallocated_maxallocated)</PRE>
<DL>
<DD>Returns information on the memory usage of fmod. This is useful for determining a fixed memory size to 
 make FMOD work within for fixed memory machines such as pocketpc and consoles
 <p>
 <b>Remarks</b>
 Note that if using FSOUND_SetMemorySystem, the memory usage will be slightly higher than without it, as fmod has to have a small amount of memory overhead to manage the available memory.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>currentallocated_maxallocated</CODE> - IntBuffer to store Currently allocated memory at time of call and
 Maximum allocated memory since FSOUND_Init or FSOUND_SetMemorySystem</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetNumDrivers()"><!-- --></A><H3>
FSOUND_GetNumDrivers</H3>
<PRE>
public static int <B>FSOUND_GetNumDrivers</B>()</PRE>
<DL>
<DD>Returns the number of sound cards or devices enumerated for the current output type. (Direct
 Sound, WaveOut etc
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Total number of enumerated sound devices</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetNumHWChannels(java.nio.IntBuffer)"><!-- --></A><H3>
FSOUND_GetNumHWChannels</H3>
<PRE>
public static boolean <B>FSOUND_GetNumHWChannels</B>(java.nio.IntBuffer&nbsp;twoD_threeD_channels_total)</PRE>
<DL>
<DD>Returns the number of available hardware mixed 2d and 3d channels
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>twoD_threeD_channels_total</CODE> - IntBuffer to store number of available hardware mixed 2d channels, 
 number of available hardware mixed 3d channels and the total (Usually num2d + num3d, but on some 
 platforms like PS2 and GameCube, this will be the same as num2d and num3d (and not the sum) because 2d and 3d voices share the same pool)
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetOutput()"><!-- --></A><H3>
FSOUND_GetOutput</H3>
<PRE>
public static int <B>FSOUND_GetOutput</B>()</PRE>
<DL>
<DD>Returns the current id to the output type.
 See FSOUND_OUTPUTTYPES for valid parameters and descriptions
<P>
<DD><DL>

<DT><B>Returns:</B><DD>id to output type</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetOutputRate()"><!-- --></A><H3>
FSOUND_GetOutputRate</H3>
<PRE>
public static int <B>FSOUND_GetOutputRate</B>()</PRE>
<DL>
<DD>Returns the current mixing rate
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Currently set output rate in Hz</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetSFXMasterVolume()"><!-- --></A><H3>
FSOUND_GetSFXMasterVolume</H3>
<PRE>
public static int <B>FSOUND_GetSFXMasterVolume</B>()</PRE>
<DL>
<DD>Returns the master volume for any sound effects played.
 It specifically has SFX in the function name, as it does not affect music or CD volume.
 This must also be altered with FMUSIC_SetMasterVolume
<P>
<DD><DL>

<DT><B>Returns:</B><DD>On success, the SFX master volume is returned. Valid ranges are from 0 (silent) to 255 (full volume)</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetVersion()"><!-- --></A><H3>
FSOUND_GetVersion</H3>
<PRE>
public static float <B>FSOUND_GetVersion</B>()</PRE>
<DL>
<DD>Returns the FMOD version number
 <p>
 <b>Remarks</b>
 Use this to compare the header you are using against the compiled DLL version to make sure your
 DLL is up to date.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>FMOD version number</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_Alloc(int, int, int, int, int, int, int)"><!-- --></A><H3>
FSOUND_Sample_Alloc</H3>
<PRE>
public static <A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A> <B>FSOUND_Sample_Alloc</B>(int&nbsp;index,
                                               int&nbsp;length,
                                               int&nbsp;mode,
                                               int&nbsp;deffreq,
                                               int&nbsp;defvol,
                                               int&nbsp;defpan,
                                               int&nbsp;defpri)</PRE>
<DL>
<DD>Allocates a new empty sample. Used if you want to create a sample from scratch and fill the databuffer with your own data (using FSOUND_Sample_Lock or FSOUND_Sample_Upload), instead of just loading a file with FSOUND_Sample_Load.
 <p>
 <b>Remarks</b>
 FMOD has a sample management system that holds onto any samples loaded or allocated, and
 frees them all when you call FSOUND_Close. It takes the hassle out of having to keep hold
 of a lot of sample handles and remember to free them all at the end of your application.
 It is basically an expandle array of handles that holds each sample until FMOD closes down where it does
 a cleanup. FSOUND_UNMANAGED can be used NOT to use the sample management system.
 ------------
 FSOUND_Sample_Alloc is only nescessary for lower level operations with sample data. Usually 
 FSOUND_Load does the work for you. lower level operations mean such things as uploading data from memory or 
 your own compressed data for example.
 You can create a new sample from scratch by doing the following operations
 1. Allocate a new sample with FSOUND_Sample_Alloc
 2. Write data to the sample buffer with FSOUND_Sample_Lock and FSOUND_Sample_Unlock, or 
 FSOUND_Sample_Upload.
 Note FSOUND_Sample_Lock only returns a pointer to the sample data, whereas 
 FSOUND_Sample_Upload does a copy from data you give it, with format conversion to the 
 correct format.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Sample pool index. See remarks for more on the sample pool.
 0 or above - The absolute index into fsounds sample pool. The pool will grow as 
 the index gets larger. If a slot is already used it will be replaced.
 FSOUND_FREE - Let FSOUND select an arbitrary sample slot. 
 FSOUND_UNMANAGED - Dont have fsound free this sample upon FSOUND_Close<DD><CODE>length</CODE> - The length in of the sample buffer in SAMPLES<DD><CODE>mode</CODE> - Bitfield describing various characteristics of the sample. Valid parameters are 
 described in FSOUND_MODES<DD><CODE>deffreq</CODE> - Default frequency for this sample<DD><CODE>defvol</CODE> - Default volume for this sample<DD><CODE>defpan</CODE> - Default pan for this sample<DD><CODE>defpri</CODE> - Default priority for this sample
<DT><B>Returns:</B><DD>On success, a reference to an allocated sample is returned. On failure, NULL is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_Free(org.lwjgl.fmod3.FSoundSample)"><!-- --></A><H3>
FSOUND_Sample_Free</H3>
<PRE>
public static void <B>FSOUND_Sample_Free</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample)</PRE>
<DL>
<DD>Removes a sample from memory and makes its slot available again
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sample</CODE> - sample definition to be freed</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_Get(int)"><!-- --></A><H3>
FSOUND_Sample_Get</H3>
<PRE>
public static <A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A> <B>FSOUND_Sample_Get</B>(int&nbsp;sampno)</PRE>
<DL>
<DD>Returns a reference to a managed sample based on the index passed
 <p>
 <b>Remarks</b>
 Samples that are not created with FSOUND_UNMANAGED are stored in a table inside FMOD.
 This way when FMOD can free all samples when FSOUND_Close is called and the user doesnt have to worry about cleaning up memory.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sampno</CODE> - index in the sample management pool of the requested sample
<DT><B>Returns:</B><DD>Reference to a sample</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_GetDefaults(org.lwjgl.fmod3.FSoundSample, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)"><!-- --></A><H3>
FSOUND_Sample_GetDefaults</H3>
<PRE>
public static boolean <B>FSOUND_Sample_GetDefaults</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                                                java.nio.IntBuffer&nbsp;deffreq,
                                                java.nio.IntBuffer&nbsp;defvol,
                                                java.nio.IntBuffer&nbsp;defpan,
                                                java.nio.IntBuffer&nbsp;defpri)</PRE>
<DL>
<DD>Returns the default volume, frequency, pan and priority values for the specified sample
 <p>
 <b>Remarks</b>
 Passing NULL in any of these parameters will result in the value being ignored
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sample</CODE> - sample to get the default information from<DD><CODE>deffreq</CODE> - IntBuffer to be filled with the sample default frequency. Can be NULL<DD><CODE>defvol</CODE> - IntBuffer to be filled with the sample default volume. Can be NULL<DD><CODE>defpan</CODE> - IntBuffer to be filled with the sample default pan. Can be NULL<DD><CODE>defpri</CODE> - IntBuffer to be filled with the sample default priority. Can be NULL
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_GetDefaultsEx(org.lwjgl.fmod3.FSoundSample, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)"><!-- --></A><H3>
FSOUND_Sample_GetDefaultsEx</H3>
<PRE>
public static boolean <B>FSOUND_Sample_GetDefaultsEx</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                                                  java.nio.IntBuffer&nbsp;deffreq,
                                                  java.nio.IntBuffer&nbsp;defvol,
                                                  java.nio.IntBuffer&nbsp;defpan,
                                                  java.nio.IntBuffer&nbsp;defpri,
                                                  java.nio.IntBuffer&nbsp;varfreq,
                                                  java.nio.IntBuffer&nbsp;varvol,
                                                  java.nio.IntBuffer&nbsp;varpan)</PRE>
<DL>
<DD>Returns the default volume, frequency, pan, priority and random playback variations for the specified sample
 <p>
 <b>Remarks</b>
 Passing NULL in any of these parameters will result in the value being ignored
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sample</CODE> - sample to get the default information from<DD><CODE>deffreq</CODE> - IntBuffer to be filled with the sample default frequency. Can be NULL<DD><CODE>defvol</CODE> - IntBuffer to be filled with the sample default volume. Can be NULL<DD><CODE>defpan</CODE> - IntBuffer to be filled with the sample default pan. Can be NULL<DD><CODE>defpri</CODE> - IntBuffer to be filled with the sample default priority. Can be NULL<DD><CODE>varfreq</CODE> - IntBuffer to be filled with the sample random frequency variance. Can be NULL<DD><CODE>varvol</CODE> - IntBuffer to be filled with the sample random volume variance. Can be NULL<DD><CODE>varpan</CODE> - IntBuffer to be filled with the sample random pan variance. Can be NULL.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_GetLength(org.lwjgl.fmod3.FSoundSample)"><!-- --></A><H3>
FSOUND_Sample_GetLength</H3>
<PRE>
public static int <B>FSOUND_Sample_GetLength</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample)</PRE>
<DL>
<DD>Returns the length of the sample in SAMPLES
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sample</CODE> - sample to get the length from
<DT><B>Returns:</B><DD>On success, the length of sample in SAMPLES is returned. On failure, 0 is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_GetLoopPoints(org.lwjgl.fmod3.FSoundSample, java.nio.IntBuffer, java.nio.IntBuffer)"><!-- --></A><H3>
FSOUND_Sample_GetLoopPoints</H3>
<PRE>
public static int <B>FSOUND_Sample_GetLoopPoints</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                                              java.nio.IntBuffer&nbsp;loopstart,
                                              java.nio.IntBuffer&nbsp;loopend)</PRE>
<DL>
<DD>Returns the start and end positions of the specified sample loop
 in SAMPLES (not bytes)
 <p>
 <b>Remarks</b>
 Passing NULL in any of these parameters will result in the value being ignored.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sample</CODE> - sample to get the loop point information from<DD><CODE>loopstart</CODE> - IntBuffer to be filled with the sample loop start point. Can be NULL<DD><CODE>loopend</CODE> - IntBuffer to be filled with the sample loop end point. Can be NULL
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_GetMinMaxDistance(org.lwjgl.fmod3.FSoundSample, java.nio.FloatBuffer, java.nio.FloatBuffer)"><!-- --></A><H3>
FSOUND_Sample_GetMinMaxDistance</H3>
<PRE>
public static int <B>FSOUND_Sample_GetMinMaxDistance</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                                                  java.nio.FloatBuffer&nbsp;min,
                                                  java.nio.FloatBuffer&nbsp;max)</PRE>
<DL>
<DD>Get the minimum and maximum audible distance for a sample
 <p>
 <b>Remarks</b>
 A 'distance unit' is specified by FSOUND_3D_SetDistanceFactor. By default this is set to meters which is a distance scale of 1.0. 
 See FSOUND_3D_SetDistanceFactor for more on this.
 The default units for minimum and maximum distances are 1.0 and 1000000000.0f.
 Volume drops off at mindistance / distance.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sample</CODE> - sample to get the distance information from<DD><CODE>min</CODE> - FloatBuffer to be filled with the sample loop start point. Can be NULL<DD><CODE>max</CODE> - FloatBuffer to be filled with the sample loop end point. Can be NULL
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_GetMode(org.lwjgl.fmod3.FSoundSample)"><!-- --></A><H3>
FSOUND_Sample_GetMode</H3>
<PRE>
public static int <B>FSOUND_Sample_GetMode</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample)</PRE>
<DL>
<DD>Returns a bitfield containing information about the specified sample. 
 The values can be bitwise AND'ed with the values contained in FSOUND_MODES to see if certain criteria are true or not. 
 Information that can be retrieved from the same in this field are loop type, bitdepth and stereo/mono.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sample</CODE> - sample to get the mode information from
<DT><B>Returns:</B><DD>On success, the sample mode is returned. On failure, 0 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_GetName(org.lwjgl.fmod3.FSoundSample)"><!-- --></A><H3>
FSOUND_Sample_GetName</H3>
<PRE>
public static java.lang.String <B>FSOUND_Sample_GetName</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample)</PRE>
<DL>
<DD>Returns a string containing the sample's name
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sample</CODE> - sample to get the loop point information from
<DT><B>Returns:</B><DD>On success, the name of the sample is returned. On failure, NULL is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_Load(int, java.nio.ByteBuffer, int)"><!-- --></A><H3>
FSOUND_Sample_Load</H3>
<PRE>
public static <A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A> <B>FSOUND_Sample_Load</B>(int&nbsp;index,
                                              java.nio.ByteBuffer&nbsp;data,
                                              int&nbsp;inputmode)</PRE>
<DL>
<DD>Loads and decodes a static soundfile into memory.
 This includes such files as .WAV, .MP2, .MP3, .OGG, .RAW and others.
 <p>
 <b>Remarks
 FMOD has a sample management system that holds onto any samples loaded or allocated, and frees them all when you call FSOUND_Close. 
 It takes the hassle out of having to keep hold of a lot of sample handles and remember to free them all at the end of your application.
 It is basically an expandle array of handles that holds each sample until FMOD closes down where it does a cleanup. 
 FSOUND_UNMANAGED can be used so FMOD does NOT use the sample management system. You have to make sure they are freed yourself.
 --------
 Specify FSOUND_LOADMEMORY to load a file from a memory image. 
 The pointer you pass to name must be the actual image of the data you want to load.
 The length parameter is to be filled out if FSOUND_LOADMEMORY is specified, otherwise if you do not specify memory loading, can be safely ignored and should be set to 0.
 --------
 Compressed formats are expanded into memory. If the file is quite large, it could take a while to load.
 --------
 If FSOUND_8BITS is specified and the file decodes to 16bit normally, FMOD will downgrade the sample to 8bit.
 --------
 On PlayStation 2, the name_or_data pointer and length variables must be 16 byte aligned, for DMA reasons.
 --------
 Note that FSOUND_NONBLOCKING is NOT supported with this function.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Sample pool index. See remarks for more on the sample pool.
 0 or above - The absolute index into the sample pool. The pool will grow as the index gets larger. If a slot is already used it will be replaced.
 FSOUND_FREE - Let FSOUND select an arbitrary sample slot.
 FSOUND_UNMANAGED - Dont have this sample managed within fsounds sample management system<DD><CODE>data</CODE> - ByteBuffer of memory image to load.<DD><CODE>inputmode</CODE> - Description of the data format, OR in the bits defined in FSOUND_MODES to describe the data being loaded.
<DT><B>Returns:</B><DD>On success, a sample is returned. On failure, NULL is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_Load(int, java.lang.String, int, int, int)"><!-- --></A><H3>
FSOUND_Sample_Load</H3>
<PRE>
public static <A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A> <B>FSOUND_Sample_Load</B>(int&nbsp;index,
                                              java.lang.String&nbsp;name,
                                              int&nbsp;inputmode,
                                              int&nbsp;offset,
                                              int&nbsp;length)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>index</CODE> - Sample pool index. See remarks for more on the sample pool.
 0 or above - The absolute index into the sample pool. The pool will grow as the index gets larger. If a slot is already used it will be replaced.
 FSOUND_FREE - Let FSOUND select an arbitrary sample slot.
 FSOUND_UNMANAGED - Dont have this sample managed within fsounds sample management system<DD><CODE>name</CODE> - Name of sound file.<DD><CODE>inputmode</CODE> - Description of the data format, OR in the bits defined in FSOUND_MODES to describe the data being loaded.<DD><CODE>offset</CODE> - Optional. 0 by default. If > 0, this value is used to specify an offset in a file, so fmod will seek before opening. length must also be specified if this value is used.<DD><CODE>length</CODE> - Optional. 0 by default. If > 0, this value is used to specify the length of a memory block when using FSOUND_LOADMEMORY, or it is the length of a file or file segment if the offset parameter is used. On PlayStation 2 this must be 16 byte aligned for memory loading.
<DT><B>Returns:</B><DD>On success, a sample is returned. On failure, NULL is returned.<DT><B>See Also:</B><DD><CODE>#FSOUND_Sample_Load(int, ByteBuffer, int, int, int)</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_Lock(org.lwjgl.fmod3.FSoundSample, int, int, org.lwjgl.fmod3.FSoundSampleLock)"><!-- --></A><H3>
FSOUND_Sample_Lock</H3>
<PRE>
public static boolean <B>FSOUND_Sample_Lock</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                                         int&nbsp;offset,
                                         int&nbsp;length,
                                         <A HREF="../../../org/lwjgl/fmod3/FSoundSampleLock.html" title="class in org.lwjgl.fmod3">FSoundSampleLock</A>&nbsp;lock)</PRE>
<DL>
<DD>Returns a reference to the beginning of the sample data for a sample.
 Data written must be signed.
 <b>NOTE:</b> This method creates 2 direct buffers on the native side, that maps to 
 the sample data. Calling this method excessively might hurt performance.
 <p>
 <b>Remarks</b>
 You must always unlock the data again after you have finished with it, using FSOUND_Sample_Unlock.
 For PCM based samples, data must be signed 8 or 16bit. For compressed samples such as those created with FSOUND_IMAADPCM, FSOUND_VAG, FSOUND_GCADPCM, the data must be in its original compressed format.
 On PlayStation 2, with FSOUND_HW2D or FSOUND_HW3D based samples, this function does not return a readable or writable buffer, it returns the SPU2 address of the sample. To send data to it you must call FSOUND_SendData.
 On GameCube, with FSOUND_HW2D or FSOUND_HW3D based samples, this function will not return the data contained within the sample. It is for upload purposes only.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sample</CODE> - sample definition<DD><CODE>offset</CODE> - Offset in BYTES to the position you want to lock in the sample buffer.<DD><CODE>length</CODE> - Number of BYTES you want to lock in the sample buffer.<DD><CODE>lock</CODE> - lock object to contain lock info
<DT><B>Returns:</B><DD>On success, true is is returned. On failure, false is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_SetDefaults(org.lwjgl.fmod3.FSoundSample, int, int, int, int)"><!-- --></A><H3>
FSOUND_Sample_SetDefaults</H3>
<PRE>
public static boolean <B>FSOUND_Sample_SetDefaults</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                                                int&nbsp;deffreq,
                                                int&nbsp;defvol,
                                                int&nbsp;defpan,
                                                int&nbsp;defpri)</PRE>
<DL>
<DD>Sets a sample's default attributes, so when it is played it uses these values without having to specify them later.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sample</CODE> - sample to have its attributes set<DD><CODE>deffreq</CODE> - Default sample frequency. The value here is specified in hz. -1 to ignore.<DD><CODE>defvol</CODE> - Default sample volume. This is a value from 0 to 255. -1 to ignore.<DD><CODE>defpan</CODE> - Default sample pan position. This is a value from 0 to 255 or FSOUND_STEREOPAN.<DD><CODE>defpri</CODE> - Default sample priority. This is a value from 0 to 255. -1 to ignore.
<DT><B>Returns:</B><DD>On success, true is is returned. On failure, false is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_SetDefaultsEx(org.lwjgl.fmod3.FSoundSample, int, int, int, int, int, int, int)"><!-- --></A><H3>
FSOUND_Sample_SetDefaultsEx</H3>
<PRE>
public static boolean <B>FSOUND_Sample_SetDefaultsEx</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                                                  int&nbsp;deffreq,
                                                  int&nbsp;defvol,
                                                  int&nbsp;defpan,
                                                  int&nbsp;defpri,
                                                  int&nbsp;varfreq,
                                                  int&nbsp;varvol,
                                                  int&nbsp;varpan)</PRE>
<DL>
<DD>Sets a sample's default attributes, so when it is played it uses these values without having to specify them later.
 <p>
 <b>Remarks</b>
 Frequency, volume and pan variation values specify a +/- variation to the 
 specified default frequency, volume and pan values i.e. with deffreq=44100, 
 varfreq=2000 the actual frequency value used will be in the range 42100 -> 46100.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sample</CODE> - sample to have its attributes set<DD><CODE>deffreq</CODE> - Default sample frequency. The value here is specified in hz. -1 to ignore.<DD><CODE>defvol</CODE> - Default sample volume. This is a value from 0 to 255. -1 to ignore.<DD><CODE>defpan</CODE> - Default sample pan position. This is a value from 0 to 255 or FSOUND_STEREOPAN.<DD><CODE>defpri</CODE> - Default sample priority. This is a value from 0 to 255. -1 to ignore.<DD><CODE>varfreq</CODE> - Frequency variation in hz to apply to deffreq each time this sample is played. -1 to ignore.<DD><CODE>varvol</CODE> - Volume variation to apply to defvol each time this sample is played. -1 to ignore.<DD><CODE>varpan</CODE> - Pan variation to apply to defpan each time this sample is played. -1 to ignore.
<DT><B>Returns:</B><DD>On success, true is is returned. On failure, false is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_SetMaxPlaybacks(org.lwjgl.fmod3.FSoundSample, int)"><!-- --></A><H3>
FSOUND_Sample_SetMaxPlaybacks</H3>
<PRE>
public static boolean <B>FSOUND_Sample_SetMaxPlaybacks</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                                                    int&nbsp;max)</PRE>
<DL>
<DD>Sets the maximum number of times a sample can play back at once
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sample</CODE> - sample to have its playback behaviour changed<DD><CODE>max</CODE> - maximum number of times a sample can play back at once
<DT><B>Returns:</B><DD>On success, true is is returned. On failure, false is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_SetMinMaxDistance(org.lwjgl.fmod3.FSoundSample, float, float)"><!-- --></A><H3>
FSOUND_Sample_SetMinMaxDistance</H3>
<PRE>
public static boolean <B>FSOUND_Sample_SetMinMaxDistance</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                                                      float&nbsp;min,
                                                      float&nbsp;max)</PRE>
<DL>
<DD>Sets the minimum and maximum audible distance for a sample.
 MinDistance is the minimum distance that the sound emitter will cease to continue growing 
 louder at (as it approaches the listener). Within the mindistance it stays at the constant loudest volume possible. Outside of this mindistance it begins to attenuate.
 MaxDistance is the distance a sound stops attenuating at. Beyond this point it will stay at the volume it would be at maxdistance units from the listener and will not attenuate any more.
 MinDistance is useful to give the impression that the sound is loud or soft in 3d space. An example of this is a small quiet object, such as a bumblebee, which you could set a mindistance of to 0.1 for example, which would cause it to attenuate quickly and dissapear when only a few meters away from the listener.
 Another example is a jumbo jet, which you could set to a mindistance of 100.0, which would keep the sound volume at max until the listener was 100 meters away, then it would be hundreds of meters more before it would fade out.
 -------
 In summary, increase the mindistance of a sound to make it 'louder' in a 3d world, and 
 decrease it to make it 'quieter' in a 3d world.
 maxdistance is effectively obsolete unless you need the sound to stop fading out at a certain point. Do not adjust this from the default if you dont need to.
 Some people have the confusion that maxdistance is the point the sound will fade out to, this is not the case
 <p>
 <b>Remarks</b>
  A 'distance unit' is specified by FSOUND_3D_SetDistanceFactor. By default this is set to meters which is a distance scale of 1.0. 
  See FSOUND_3D_SetDistanceFactor for more on this.
  The default units for minimum and maximum distances are 1.0 and 1000000000.0f.
  Volume drops off at mindistance / distance.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sample</CODE> - sample to have its minimum and maximum distance set<DD><CODE>min</CODE> - The samples minimum volume distance in "units". See remarks for more on units.<DD><CODE>max</CODE> - The samples maximum volume distance in "units". See remarks for more on units.
<DT><B>Returns:</B><DD>On success, true is is returned. On failure, false is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_SetMode(org.lwjgl.fmod3.FSoundSample, int)"><!-- --></A><H3>
FSOUND_Sample_SetMode</H3>
<PRE>
public static boolean <B>FSOUND_Sample_SetMode</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                                            int&nbsp;mode)</PRE>
<DL>
<DD>Sets a sample's mode. This can only be FSOUND_LOOP_OFF,FSOUND_LOOP_NORMAL, FSOUND_LOOP_BIDI or FSOUND_2D.
 You cannot change the description of the contents of a sample or its location. FSOUND_2D will be ignored on the Win32 platform if FSOUND_HW3D was used to create the sample.
 
 <p>
 <b>Remarks</b>
 Only the following modes are accepted, others will be filtered out. 
 FSOUND_LOOP_BIDI, FSOUND_LOOP_NORMAL, FSOUND_LOOP_OFF, FSOUND_2D.
 Normally FSOUND_2D is accepted only if the sound is software mixed. If this is not set, the mode is set for the sample to be 3D processed.
 -------------------
 On Playstation 2, XBox and GameCube, FSOUND_HW2D and FSOUND_HW3D are supported, so you can change between the 2 at runtime.
 -------------------
 On Windows, samples created with FSOUND_HW3D or FSOUND_HW2D do not support FSOUND_LOOP_BIDI. This is a limitation of Direct X.   * </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sample</CODE> - sample to have the mode set<DD><CODE>mode</CODE> - mode bits to set from FSOUND_MODES
<DT><B>Returns:</B><DD>On success, true is is returned. On failure, false is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="nFSOUND_Sample_SetLoopPoints(org.lwjgl.fmod3.FSoundSample, int, int)"><!-- --></A><H3>
nFSOUND_Sample_SetLoopPoints</H3>
<PRE>
public static boolean <B>nFSOUND_Sample_SetLoopPoints</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                                                   int&nbsp;loopstart,
                                                   int&nbsp;loopend)</PRE>
<DL>
<DD>Sets a sample's loop points, specified in SAMPLES, not bytes
 <p>
 <b>Remarks</b>
 Samples created with FSOUND_HW3D and FSOUND_HW2D under the FSOUND_OUTPUT_DSOUND output mode do not support this function. 
 Loop points set on such a sample with be ignored, and the sample will loop in its entirety. This is a limitation of DirectSound.
 On XBOX, GameCube and Playstation 2 hardware voices using compressed data (ie XADPCM, VAG or GCADPCM), these values will not be sample accurate, but will be rounded to the nearest compression block size.
 On PlayStation 2, the loopend is ignored. The hardware cannot change the end address, so the loopend is always equivalent to length - 1 no matter what you set.   *
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sample</CODE> - sample to have its loop points set<DD><CODE>loopstart</CODE> - The starting position of the sample loop<DD><CODE>loopend</CODE> - The end position of the sample loop
<DT><B>Returns:</B><DD>On success, true is is returned. On failure, false is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_Unlock(org.lwjgl.fmod3.FSoundSample, org.lwjgl.fmod3.FSoundSampleLock)"><!-- --></A><H3>
FSOUND_Sample_Unlock</H3>
<PRE>
public static boolean <B>FSOUND_Sample_Unlock</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                                           <A HREF="../../../org/lwjgl/fmod3/FSoundSampleLock.html" title="class in org.lwjgl.fmod3">FSoundSampleLock</A>&nbsp;lock)</PRE>
<DL>
<DD>Releases previous sample data lock from FSOUND_Sample_Lock
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sample</CODE> - sample definition<DD><CODE>lock</CODE> - lock object that contains lock info
<DT><B>Returns:</B><DD>On success, true is is returned. On failure, false is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Sample_Upload(org.lwjgl.fmod3.FSoundSample, java.nio.ByteBuffer, int)"><!-- --></A><H3>
FSOUND_Sample_Upload</H3>
<PRE>
public static boolean <B>FSOUND_Sample_Upload</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                                           java.nio.ByteBuffer&nbsp;srcdata,
                                           int&nbsp;mode)</PRE>
<DL>
<DD>This function uploads new sound data from memory to a preallocated/existing sample and does conversion based on the specified source mode.
 If sample data already exists at this handle then it is replaced with the new data being uploaded
 <p>
 <b>Remarks</b>
 Note that on PlayStation 2 the source data address is an IOP address not an EE address. 
 To get data from EE RAM to the sample you must allocate some IOP memory, dma it to IOP memory then call upload. There are helper functions in fmodps2.h to achieve this.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sample</CODE> - the destination sample<DD><CODE>srcdata</CODE> - ByteBuffer to the source data to be uploaded. On PlayStation 2 this is an IOP address not an EE address.<DD><CODE>mode</CODE> - Description of the source data format. Bitwise OR in these bits to describe the data being passed in.
 See FSOUND_MODES for valid parameters and descriptions.
 FSOUND_HW3D, FSOUND_HW2D and FSOUND_LOOP modes are ignored, the mode describes the source format, not the destination format.
<DT><B>Returns:</B><DD>On success, true is is returned. On failure, false is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_PlaySound(int, org.lwjgl.fmod3.FSoundSample)"><!-- --></A><H3>
FSOUND_PlaySound</H3>
<PRE>
public static int <B>FSOUND_PlaySound</B>(int&nbsp;channel,
                                   <A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample)</PRE>
<DL>
<DD>Plays a sample in a specified channel, using the sample's default frequency, volume
 and pan settings.
 <p>
 <b>Remarks</b>
 If you play a FSOUND_HW3D declared sample with this function, then the position and velocity
 are set to those of the listener. Other attributes such as volume, frequency and pan are taken
 from the sample's default volume, frequency, pan etc.
 ----------
 The channel handle :
 The return value is reference counted. This stops the user from updating a stolen channel.
 Basically it means the only sound you can change the attributes (ie volume/pan/frequency/3d position) for are the one you specifically called playsound for. If another sound steals that channel, and you keep trying to change its attributes (ie volume/pan/frequency/3d position), it will do nothing.
 This is great if you have sounds being updated from tasks and you just forget about it.
 You can keep updating the sound attributes and if another task steals that channel, your original task wont change the attributes of the new sound!!!
 The lower 12 bits contain the channel number. (yes this means a 4096 channel limit for FMOD :)
 The upper 19 bits contain the reference count.
 The top 1 bit is the sign bit.
 ie
 S RRRRRRRRRRRRRRRRRRR CCCCCCCCCCCC
 ----------
 Remember if not using FSOUND_FREE, then the channel pool is split up into software and hardware channels.
 Software channels occupy the first n indicies specified by the value passed into FSOUND_Init.
 Hardware channels occupy the next n indicies after this, and can be a variable amount, depending on the hardware.
 Use FSOUND_GetNumHardwareChannels to query how many channels are available in hardware.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - 0+ 
 The absolute channel number in the channel pool. 
 Remember software channels come first, followed by hardware channels. 
 You cannot play a software sample on a hardware channel and vice versa.
 FSOUND_FREE 
 Chooses a free channel to play in. If all channels are used then it
 selects a channel with a sample playing that has an EQUAL or LOWER priority 
 than the sample to be played.
 FSOUND_ALL
 Passing this will cause ALL channels to play. (note this will make things
 VERY noisy!)
 If FSOUND_ALL is used the last channel success flag will be returned.<DD><CODE>sample</CODE> - to be played
<DT><B>Returns:</B><DD>On success, the channel handle that was selected is returned. On failure, -1 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="nFSOUND_PlaySoundEx(int, org.lwjgl.fmod3.FSoundSample, org.lwjgl.fmod3.FSoundDSPUnit, boolean)"><!-- --></A><H3>
nFSOUND_PlaySoundEx</H3>
<PRE>
public static int <B>nFSOUND_PlaySoundEx</B>(int&nbsp;channel,
                                      <A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                                      <A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A>&nbsp;dspunit,
                                      boolean&nbsp;startpaused)</PRE>
<DL>
<DD>Extended featured version of FSOUND_PlaySound.
 New functionality includes the ability to start the sound paused. 
 This allows attributes of a channel to be set freely before the sound actually starts playing, until FSOUND_SetPaused(FALSE) is used.
 Also added is the ability to associate the channel to a specified DSP unit. This allows the user to 'group' channels into seperate DSP units, which allows effects to be inserted between these 'groups', and allow various things like having one group affected by reverb (wet mix) and another group of channels unaffected (dry). 
 This is useful to seperate things like music from being affected by DSP effects, while other sound effects are.
 <p>
 <b>Remarks</b>
 FSOUND_ALL is supported. Passing this will cause ALL channels to play. (note this could make things VERY noisy!)
 If FSOUND_ALL is used the last channel success flag will be returned. This return value is not useful in most circumstances.
 ----------
 The channel handle :
 The return value is reference counted. This stops the user from updating a stolen channel.
 This means the only sound you can change the attributes (ie volume/pan/frequency/3d position) for are the 
 one you specifically called playsound for. If another sound steals that channel, and you keep trying to 
 change its attributes (ie volume/pan/frequency/3d position), it will do nothing.
 This is great if you have sounds being updated from tasks and you just forget about it.
 You can keep updating the sound attributes and if another task steals that channel, your original task 
 wont change the attributes of the new sound!!!
 The lower 12 bits contain the channel number. (yes this means a 4096 channel limit for FMOD :)
 The upper 19 bits contain the reference count.
 The top 1 bit is the sign bit.
 ie
 S RRRRRRRRRRRRRRRRRRR CCCCCCCCCCCC
 ----------
 Remember if not using FSOUND_FREE, then the channel pool is split up into software and hardware channels.
 Software channels occupy the first n indicies specified by the value passed into FSOUND_Init.
 Hardware channels occupy the next n indicies after this, and can be a variable amount, depending on the hardware.
 Use FSOUND_GetNumHardwareChannels to query how many channels are available in hardware.
 ----------
 If you attach a sound to a DSP unit (for grouping purposes), the callback for the DSP unit will be overwritten with fmod's internal mixer callback, so the callback the user supplied is rendered obsolete and is not called.
 Also, do not attach sounds to system DSP units, the assignment will be ignored if you do.   
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - 0+ 
 The absolute channel number in the channel pool. 
 Remember software channels come first, followed by hardware channels. 
 You cannot play a software sample on a hardware channel and vice versa.
 FSOUND_FREE 
 Chooses a free channel to play in. If all channels are used then it
 selects a channel with a sample playing that has an EQUAL or LOWER priority 
 than the sample to be played.
 FSOUND_ALL
 Passing this will cause ALL channels to play. (note this will make things
 VERY noisy!)
 If FSOUND_ALL is used the last channel success flag will be returned.<DD><CODE>sample</CODE> - to be played<DD><CODE>dspunit</CODE> - Optional. NULL by default. Pointer to a dsp unit to attach the channel to for channel grouping. Only attach a sound to a user created DSP unit, and not a system DSP unit.<DD><CODE>startpaused</CODE> - Start the sound paused or not. Pausing the sound allows attributes to be set before the sound starts
<DT><B>Returns:</B><DD>On success, the channel handle that was selected is returned. On failure, -1 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_StopSound(int)"><!-- --></A><H3>
FSOUND_StopSound</H3>
<PRE>
public static boolean <B>FSOUND_StopSound</B>(int&nbsp;channel)</PRE>
<DL>
<DD>Stops a specified sound channel from playing, and frees it up for re-use
 <p>
 <b>Remarks</b>
 FSOUND_ALL is supported. Passing this will cause ALL channels to stop.
 If FSOUND_ALL is used the last channel success flag will be returned. This return value is not useful in most circumstances.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to stop. FSOUND_ALL can also be used (see remarks)
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetFrequency(int, int)"><!-- --></A><H3>
FSOUND_SetFrequency</H3>
<PRE>
public static boolean <B>FSOUND_SetFrequency</B>(int&nbsp;channel,
                                          int&nbsp;freq)</PRE>
<DL>
<DD>Sets a channels frequency or playback rate, in Hz.
 <p>
 <b>Remarks</b>
 FSOUND_ALL is supported here. Passing this will set ALL channels to specified frequency.
 If FSOUND_ALL is used the last channel success flag will be returned. This return value is not useful in most circumstances.
 Negative frequencies make the sound play backwards, so FSOUND_SetCurrentPosition would be needed to set the sound to the right position. 
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to stop. FSOUND_ALL can also be used (see remarks)<DD><CODE>freq</CODE> - The frequency to set. Valid ranges are from 100 to 705600, and -100 to -705600
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetLevels(int, int, int, int, int, int, int)"><!-- --></A><H3>
FSOUND_SetLevels</H3>
<PRE>
public static boolean <B>FSOUND_SetLevels</B>(int&nbsp;channel,
                                       int&nbsp;frontleft,
                                       int&nbsp;center,
                                       int&nbsp;frontright,
                                       int&nbsp;backleft,
                                       int&nbsp;backright,
                                       int&nbsp;lfe)</PRE>
<DL>
<DD>XBox Only - For surround sound systems, this function allows each surround speaker level to be set individually for this channel
 <p>
 <b>Remarks</b>
 FSOUND_ALL is supported. Passing this will set the pan of ALL channels available.
 If FSOUND_ALL is used the last channel success flag will be returned. This return value is not useful in most circumstances.
 ----------
 FSOUND_SYSTEMCHANNEL is supported. You can set the mix levels for the FMOD software engine, and ALL software mixed sounds will be affected.   * </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to change the output levels for. FSOUND_ALL and FSOUND_SYSTEMCHANNEL can also be used (see remarks)<DD><CODE>frontleft</CODE> - Value from 0 to 255 inclusive, specifying a linear level for the front left speaker.<DD><CODE>center</CODE> - Value from 0 to 255 inclusive, specifying a linear level for the center.<DD><CODE>frontright</CODE> - Value from 0 to 255 inclusive, specifying a linear level for the front right speaker.<DD><CODE>backleft</CODE> - Value from 0 to 255 inclusive, specifying a linear level for the back left speaker.<DD><CODE>backright</CODE> - Value from 0 to 255 inclusive, specifying a linear level for the back right speaker.<DD><CODE>lfe</CODE> - Value from 0 to 255 inclusive, specifying a linear level for the subwoofer speaker.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetLoopMode(int, int)"><!-- --></A><H3>
FSOUND_SetLoopMode</H3>
<PRE>
public static boolean <B>FSOUND_SetLoopMode</B>(int&nbsp;channel,
                                         int&nbsp;loopmode)</PRE>
<DL>
<DD>Sets the loop mode for a particular CHANNEL, not sample
 <p>
 <b>Remarks</b>
 FSOUND_ALL is supported. Passing this will set loop modes for all channels available.
 Note, this does not work for hardware sounds played on hardware channels while they are playing. The function has to be called when the channel is paused.
 Software based sounds do not have this limitation, and can have their loop mode changed during playback, but for compatibility it is best to use the pause method, else you may get different behaviour if hardware voices do not exist.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to change the output levels for. FSOUND_ALL and FSOUND_SYSTEMCHANNEL can also be used (see remarks)<DD><CODE>loopmode</CODE> - The loopmode to set. This can be FSOUND_LOOP_NORMAL, FSOUND_LOOP_BIDI or FSOUND_LOOP_OFF.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetMute(int, boolean)"><!-- --></A><H3>
FSOUND_SetMute</H3>
<PRE>
public static boolean <B>FSOUND_SetMute</B>(int&nbsp;channel,
                                     boolean&nbsp;mute)</PRE>
<DL>
<DD>Mutes and un-mutes a channel
 <p>
 <b>Remarks</b>
 FSOUND_ALL is supported. Passing this will mute/unmute ALL channels available.
 If FSOUND_ALL is used the last channel success flag will be returned. This return value is not useful in most circumstances.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to change the output levels for. FSOUND_ALL and FSOUND_SYSTEMCHANNEL can also be used (see remarks)<DD><CODE>mute</CODE> - Toggle value - TRUE mutes out the channel, FALSE reenables it.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetPan(int, int)"><!-- --></A><H3>
FSOUND_SetPan</H3>
<PRE>
public static boolean <B>FSOUND_SetPan</B>(int&nbsp;channel,
                                    int&nbsp;pan)</PRE>
<DL>
<DD>Sets a channels pan position linearly
 <p>
 <b>Remarks</b>
 FSOUND_ALL is supported. Passing this will set the pan of ALL channels available.
 If FSOUND_ALL is used the last channel success flag will be returned. This return value is not useful in most circumstances.
 ----------
 Important : If you are playing a STEREO sample, and using normal middle panning, it will only come out at half the volume 
 they are supposed to. To avoid this use FSOUND_STEREO pan.
 Panning works in the following manner:
 full left : 100to left, 0to right
 full right : 0to left, 100to right
 middle : 71to left, 71to right
 FMOD Uses 'constant power' panning. The center position is 71 4738960n each channel as it keeps an even RMS output level when
 moving the sound from left to right. Placing 50 4738960n each channel for a middle position is incorrect.
 The pan graph for constant power panning resembles a curve instead of straight lines.   * </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to change the output levels for. FSOUND_ALL and FSOUND_SYSTEMCHANNEL can also be used (see remarks)<DD><CODE>pan</CODE> - The panning position for this channel to set.
 parameters are:
 - from 0 (full left) to 255 (full right)
 - FSOUND_STEREOPAN. This is meant for stereo samples, but will work on mono 
 samples as well. It makes both left and right FULL volume instead of 50/50
 as middle panning does. See remarks section for more information on this
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetPaused(int, boolean)"><!-- --></A><H3>
FSOUND_SetPaused</H3>
<PRE>
public static boolean <B>FSOUND_SetPaused</B>(int&nbsp;channel,
                                       boolean&nbsp;paused)</PRE>
<DL>
<DD>Pauses or unpauses a sound channel
 <p>
 <b>Remarks</b>
 FSOUND_ALL is supported. Passing this will pause/unpause ALL channels available.
 If FSOUND_ALL is used the last channel success flag will be returned. This return value is not useful in most circumstances.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to change the output levels for. FSOUND_ALL and FSOUND_SYSTEMCHANNEL can also be used (see remarks)<DD><CODE>paused</CODE> - TRUE pauses this channel, FALSE unpauses it.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetPriority(int, int)"><!-- --></A><H3>
FSOUND_SetPriority</H3>
<PRE>
public static boolean <B>FSOUND_SetPriority</B>(int&nbsp;channel,
                                         int&nbsp;priority)</PRE>
<DL>
<DD>Sets a channels priority. Higher priority means it is less likely to get discarded when
 FSOUND_FREE is used to select a channel, when all channels are being used, and one has to 
 be rejected. If a channel has an equal priority then it will be replaced.
 <p>
 <b>Remarks</b>
 FSOUND_ALL is supported. Passing this will pause/unpause ALL channels available.
 If FSOUND_ALL is used the last channel success flag will be returned. This return value is not useful in most circumstances.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to change the output levels for. FSOUND_ALL and FSOUND_SYSTEMCHANNEL can also be used (see remarks)<DD><CODE>priority</CODE> - The priority to set. Valid ranges are from 0 (lowest) to 255 (highest)
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetReserved(int, boolean)"><!-- --></A><H3>
FSOUND_SetReserved</H3>
<PRE>
public static boolean <B>FSOUND_SetReserved</B>(int&nbsp;channel,
                                         boolean&nbsp;reserved)</PRE>
<DL>
<DD>This sets the reserved status of a channel. Reserving a channel is related to setting its
 priority, but reserving a channel means it can NEVER be stolen by a channel request. It 
 could be thought of as an extra high priority, but is different in that reserved channels do
 not steal from each other, whereas channels with equal priorities do (unless there are 
 channels with lower priorities that it can steal from). If all channels were reserved and 
 another request for came in for a channel, it would simply fail and the sound would not be 
 played.
 <p>
 <b>Remarks</b>
 FSOUND_ALL is supported. Passing this will pause/unpause ALL channels available.
 If FSOUND_ALL is used the last channel success flag will be returned. This return value is not useful in most circumstances.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to change the priority for. 
 FSOUND_ALL can also be used (see remarks).
 FSOUND_FREE is NOT accepted.<DD><CODE>reserved</CODE> - Reserved flag. Values accepted are TRUE, to reserve a channel, and FALSE to 
 un-reserve a channel.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetSurround(int, boolean)"><!-- --></A><H3>
FSOUND_SetSurround</H3>
<PRE>
public static boolean <B>FSOUND_SetSurround</B>(int&nbsp;channel,
                                         boolean&nbsp;surround)</PRE>
<DL>
<DD>Sets a channels surround sound status. This surround sound is a fake dolby trick that 
 effectively pans the channel to the center, but inverts the waveform in one speaker to
 make it sound fuller or spacier, or like it is coming out of space between the 2 speakers.
 Panning is ignored while surround is in effect.
 <p>
 <b>Remarks</b>
 FSOUND_ALL is supported. Passing this will pause/unpause ALL channels available.
 If FSOUND_ALL is used the last channel success flag will be returned. This return value is not useful in most circumstances.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to change the surround for. FSOUND_ALL can also be used (see remarks).<DD><CODE>surround</CODE> - Toggle value - TRUE enables surround sound on the channel, FALSE disables it.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetVolume(int, int)"><!-- --></A><H3>
FSOUND_SetVolume</H3>
<PRE>
public static boolean <B>FSOUND_SetVolume</B>(int&nbsp;channel,
                                       int&nbsp;vol)</PRE>
<DL>
<DD>Sets a channels volume linearly.
 This function IS affected by FSOUND_SetSFXMasterVolume.
 <p>
 <b>Remarks</b>
 FSOUND_ALL is supported. Passing this will pause/unpause ALL channels available.
 If FSOUND_ALL is used the last channel success flag will be returned. This return value is not useful in most circumstances.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to change the volume for. FSOUND_ALL can also be used (see remarks)<DD><CODE>vol</CODE> - The volume to set. Valid ranges are from 0 (silent) to 255 (full volume)
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetVolumeAbsolute(int, int)"><!-- --></A><H3>
FSOUND_SetVolumeAbsolute</H3>
<PRE>
public static boolean <B>FSOUND_SetVolumeAbsolute</B>(int&nbsp;channel,
                                               int&nbsp;vol)</PRE>
<DL>
<DD>Sets a channels volume linearly.
 This function is NOT affected by master volume.
 This function is used when you want to quiet everything down using FSOUND_SetSFXMasterVolume, but make 
 a channel prominent.
 <p>
 <b>Remarks</b>
 FSOUND_ALL is supported. Passing this will set the absolute volume of ALL channels available.
 If FSOUND_ALL is used the last channel success flag will be returned. This return value is not useful in most circumstances.
 -------------
 A good example of this function being used for a game needing a voice over.
 If all the background sounds were too loud and drowned out the voice over, there is no way to
 feasibly go through all the sfx channels and lower the background noise volumes (some might be allocated by music). 
 Simply lower the background noise with FSOUND_SetSFXMasterVolume, and use FSOUND_SetVolumeAbsolute to bring 
 up the volume of the voice over to full, and you will get one channel standing out amongst the rest.   * </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to change the volume for. FSOUND_ALL can also be used (see remarks)<DD><CODE>vol</CODE> - The volume to set. Valid ranges are from 0 (silent) to 255 (full volume)
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetVolume(int)"><!-- --></A><H3>
FSOUND_GetVolume</H3>
<PRE>
public static int <B>FSOUND_GetVolume</B>(int&nbsp;channel)</PRE>
<DL>
<DD>Returns the linear volume of the specified channel between 0 and 255
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - Channel to get volume from
<DT><B>Returns:</B><DD>On success, the following values are returned : 0 = silent to 255 = full volume.
 On failure, 0 is returned. To quailfy if this is a real error, call FSOUND_GetError.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetAmplitude(int)"><!-- --></A><H3>
FSOUND_GetAmplitude</H3>
<PRE>
public static int <B>FSOUND_GetAmplitude</B>(int&nbsp;channel)</PRE>
<DL>
<DD>Returns the volume of the channel based on all combinations of set volume, mastervolume and 3d position.
 Works on software and hardware voices.
 <p>
 <b>Remarks</b>
 This is not the same as FSOUND_GetCurrentLevels, as that function takes the actual waveform data into account.
 This function simply gives a final volume based on 3d position and volume settings.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - Channel to get amplitude from
<DT><B>Returns:</B><DD>On success, the following values are returned : 0 = silent to 255 = full volume.
 On failure, 0 is returned. To quailfy if this is a real error, call FSOUND_GetError.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_3D_SetAttributes(int, java.nio.FloatBuffer, java.nio.FloatBuffer)"><!-- --></A><H3>
FSOUND_3D_SetAttributes</H3>
<PRE>
public static boolean <B>FSOUND_3D_SetAttributes</B>(int&nbsp;channel,
                                              java.nio.FloatBuffer&nbsp;pos,
                                              java.nio.FloatBuffer&nbsp;vel)</PRE>
<DL>
<DD>This updates the position and velocity of a 3d sound playing on a channel
 <p>
 <b>Remarks</b>
 FSOUND treats +X as right, +Y as up, and +Z as forwards.
 ---------
 A 'distance unit' is specified by FSOUND_3D_SetDistanceFactor. By default this is set to meters which is a distance scale of 1.0. 
 See FSOUND_3D_SetDistanceFactor for more on this.
 ---------
 FSOUND vectors expect 3 floats representing x y and z in that order. I.e. a typical definition
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - Channel you want to apply 3d positioning to.<DD><CODE>pos</CODE> - Pointer to a position vector (xyz float triplet) of the emitter in world space, measured in distance units.
 This can be NULL to ignore it.<DD><CODE>vel</CODE> - Pointer to a velocity vector (xyz float triplet), of the emitter measured in distance units PER SECOND.
 This can be NULL to ignore it.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_3D_SetMinMaxDistance(int, float, float)"><!-- --></A><H3>
FSOUND_3D_SetMinMaxDistance</H3>
<PRE>
public static boolean <B>FSOUND_3D_SetMinMaxDistance</B>(int&nbsp;channel,
                                                  float&nbsp;min,
                                                  float&nbsp;max)</PRE>
<DL>
<DD>Sets the minimum and maximum audible distance for a channel.
 MinDistance is the minimum distance that the sound emitter will cease to continue growing 
 louder at (as it approaches the listener). Within the mindistance it stays at the constant loudest volume possible. Outside of this mindistance it begins to attenuate.
 MaxDistance is the distance a sound stops attenuating at. Beyond this point it will stay at the volume it would be at maxdistance units from the listener and will not attenuate any more.
 MinDistance is useful to give the impression that the sound is loud or soft in 3d space. An example of this is a small quiet object, such as a bumblebee, which you could set a mindistance of to 0.1 for example, which would cause it to attenuate quickly and dissapear when only a few meters away from the listener.
 Another example is a jumbo jet, which you could set to a mindistance of 100.0, which would keep the sound volume at max until the listener was 100 meters away, then it would be hundreds of meters more before it would fade out.
 -------
 In summary, increase the mindistance of a sound to make it 'louder' in a 3d world, and 
 decrease it to make it 'quieter' in a 3d world.
 maxdistance is effectively obsolete unless you need the sound to stop fading out at a certain point. Do not adjust this from the default if you dont need to.
 Some people have the confusion that maxdistance is the point the sound will fade out to, this is not the case.
 <p>
 <b>Remarks</b>
 FSOUND_ALL is supported. Passing this will set the min/max distance on ALL channels available.
 A 'distance unit' is specified by FSOUND_3D_SetDistanceFactor. By default this is set to meters which is a distance scale of 1.0. 
 See FSOUND_3D_SetDistanceFactor for more on this.
 The default units for minimum and maximum distances are 1.0 and 1000000000.0f.
 Volume drops off at mindistance / distance.
 To define the min and max distance per sound and not per channel use FSOUND_Sample_SetMinMaxDistance.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel to have its minimum and maximum distance set.<DD><CODE>min</CODE> - The channels minimum volume distance in "units". See remarks for more on units.<DD><CODE>max</CODE> - The channels maximum volume distance in "units". See remarks for more on units.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_SetCurrentPosition(int, int)"><!-- --></A><H3>
FSOUND_SetCurrentPosition</H3>
<PRE>
public static boolean <B>FSOUND_SetCurrentPosition</B>(int&nbsp;channel,
                                                int&nbsp;offset)</PRE>
<DL>
<DD>Sets the current position of the sound in SAMPLES not bytes
 <p>
 <b>Remarks</b>
 FSOUND_ALL is supported. Passing this set the current position for the sound on ALL channels available.
 On XBOX, GameCube and Playstation 2 hardware voices using compressed data (ie XADPCM, VAG or GCADPCM), 
 this value will not be sample accurate, but will be rounded to the nearest compression block size. 
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to have its offset or position set.<DD><CODE>offset</CODE> - The offset in SAMPLES from the start of the sound for the position to be set to.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetCurrentPosition(int)"><!-- --></A><H3>
FSOUND_GetCurrentPosition</H3>
<PRE>
public static int <B>FSOUND_GetCurrentPosition</B>(int&nbsp;channel)</PRE>
<DL>
<DD>Returns the current playcursor position of the specified channel
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - Channel number/handle to get the current position from.
<DT><B>Returns:</B><DD>On success, the play cursor position in SAMPLES is returned for the specified channel.
 On failure, 0 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetCurrentSample(int)"><!-- --></A><H3>
FSOUND_GetCurrentSample</H3>
<PRE>
public static <A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A> <B>FSOUND_GetCurrentSample</B>(int&nbsp;channel)</PRE>
<DL>
<DD>Returns the current sample being played on the specified channel
 <p>
 <b>Remarks</b>
 Note that current sample does not return to NULL when a sound has ended.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - Channel number/handle to get the currently playing sample from.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetCurrentLevels(int, java.nio.FloatBuffer)"><!-- --></A><H3>
FSOUND_GetCurrentLevels</H3>
<PRE>
public static boolean <B>FSOUND_GetCurrentLevels</B>(int&nbsp;channel,
                                              java.nio.FloatBuffer&nbsp;l_r)</PRE>
<DL>
<DD>Returns a left and right VU/Level reading at the current position of the specified channel.
 Levels are are only supported for software channels.
 <p>
 <b>Remarks</b>
 By default this function is only point sampled and not latency adjusted (it will appear to trigger ahead of when you hear the sound).
 To fix this and get a 'perfect' set of levels in realtime, use FSOUND_INIT_ACCURATEVULEVELS with FSOUND_Init.
 -------------------
 To get an overall VU reading for all sounds, add all VU values for each channel together, and then clip at 1.0. 
 Another (harder) way is to write a dsp unit that reads from the mixbuffer being passed into it.
 Note: A true 'VU' should be smoothed, but in case people were after more accuracy than a smoothed value, it was decided to return the raw amplitude, and let the user smooth the result in their own way.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - Channel number/handle to retrieve left and right level from.<DD><CODE>l_r</CODE> - FloatBuffer to store left and right level, each between 0 and 1.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetFrequency(int)"><!-- --></A><H3>
FSOUND_GetFrequency</H3>
<PRE>
public static int <B>FSOUND_GetFrequency</B>(int&nbsp;channel)</PRE>
<DL>
<DD>Returns the frequency in HZ of the specified channel
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The number/handle to get the frequency from.
<DT><B>Returns:</B><DD>On success, the frequency in HZ of the specified channel is returned.
 On failure, 0 is returned. To quailfy if this is a real error, call FSOUND_GetError.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetLoopMode(int)"><!-- --></A><H3>
FSOUND_GetLoopMode</H3>
<PRE>
public static int <B>FSOUND_GetLoopMode</B>(int&nbsp;channel)</PRE>
<DL>
<DD>Gets the loop mode for a particular channel
 <p>
 <b>Remarks</b>
 This works for all channel types, whereas setting it will not work.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to get the loop mode from.
<DT><B>Returns:</B><DD>On success, the loop mode is returned. On failure, 0 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetMixer()"><!-- --></A><H3>
FSOUND_GetMixer</H3>
<PRE>
public static int <B>FSOUND_GetMixer</B>()</PRE>
<DL>
<DD>Returns the currently used mixer type
<P>
<DD><DL>

<DT><B>Returns:</B><DD>FSOUND_GetMixer returns a defenition from FSOUND_MIXERTYPES. See FSOUND_MIXERTYPES for valid parameters and descriptions.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetMute(int)"><!-- --></A><H3>
FSOUND_GetMute</H3>
<PRE>
public static boolean <B>FSOUND_GetMute</B>(int&nbsp;channel)</PRE>
<DL>
<DD>Returns if the channel specified is muted or not
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to get the mute status from
<DT><B>Returns:</B><DD>TRUE - The channel has mute turned ON. FALSE - The channel has mute turned OFF</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetNumSubChannels(int)"><!-- --></A><H3>
FSOUND_GetNumSubChannels</H3>
<PRE>
public static int <B>FSOUND_GetNumSubChannels</B>(int&nbsp;channel)</PRE>
<DL>
<DD>This function returns the number of sub-channels stored in a multi-channel channel handle, which is only possible when playing back a multichannel .FSB file.
 <p>
 <b>Remarks</b>
 A multichannel sound, only possible with the .FSB format, can contain multiple subchannels. When a multichannel sound is played, multiple channels are allocated at the same time.
 For example, a 8 sounds/streams can be interleaved into a multichannel FSB. This function would return 8, as 8 real hardware/software voices are used during playback.
 FSOUND_GetSubChannel can be used to get access to the secondary channels.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The value returned by FSOUND_Stream_Play, FSOUND_Stream_PlayEx, FSOUND_PlaySound, FSOUND_PlaySoundEx.
<DT><B>Returns:</B><DD>On success, the number of subchannels is returned. On failure, 0 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetPan(int)"><!-- --></A><H3>
FSOUND_GetPan</H3>
<PRE>
public static int <B>FSOUND_GetPan</B>(int&nbsp;channel)</PRE>
<DL>
<DD>Returns the linear pan position of the specified channel between 0 and 255
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to get the pan from.
<DT><B>Returns:</B><DD>On success, the following values are returned : 0 = full left to 128 = middle to 255 = full right, FSOUND_STEREOPAN
 On failure, 0 is returned. To quailfy if this is a real error, call FSOUND_GetError.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetPaused(int)"><!-- --></A><H3>
FSOUND_GetPaused</H3>
<PRE>
public static boolean <B>FSOUND_GetPaused</B>(int&nbsp;channel)</PRE>
<DL>
<DD>Gets current pause status of the channel
 <p>
 <b>Remarks</b>
  This function is useful for games that have a pause mode, and you dont want the sounds
  to continue playing, but you would like them to continue on from where they left off 
 when you unpause.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to get the paused status from.
<DT><B>Returns:</B><DD>TRUE - The channel is currently paused.
 FALSE - The channel is running.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetPriority(int)"><!-- --></A><H3>
FSOUND_GetPriority</H3>
<PRE>
public static int <B>FSOUND_GetPriority</B>(int&nbsp;channel)</PRE>
<DL>
<DD>Gets a sound channels priority. Priority is used to determine if soundeffects should 
 replace other sound effects when the channel limit has been reached. See 
 FSOUND_SetPriority for more information.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to get the priority from.
<DT><B>Returns:</B><DD>On success, the priority of the channel is returned. Ranges between 0 and 255.
 On failure, 0 is returned. To quailfy if this is a real error, call FSOUND_GetError.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetReserved(int)"><!-- --></A><H3>
FSOUND_GetReserved</H3>
<PRE>
public static int <B>FSOUND_GetReserved</B>(int&nbsp;channel)</PRE>
<DL>
<DD>Gets a sound channels reserved status. priority is used to determine if soundeffects should muscle
 out other sound effects when the channel limit has been reached.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to get the reserved status from.
<DT><B>Returns:</B><DD>TRUE Channel is reserved and cannot be selected.
 FALSE Channel is reserved and can be selected.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetSubChannel(int, int)"><!-- --></A><H3>
FSOUND_GetSubChannel</H3>
<PRE>
public static int <B>FSOUND_GetSubChannel</B>(int&nbsp;channel,
                                       int&nbsp;subchannel)</PRE>
<DL>
<DD>This function returns a channel handle from a subchannel within a multichannel FSB file, so that it can be maniuplated seperately, instead of controlling the whole multichannel array with the parent channel that the user retrieves from FSOUND_PlaySound etc.
 <p>
 <b>Remarks</b>
 A multichannel sound, only possible with the .FSB format, can contain multiple subchannels. When a multichannel sound is played, multiple channels are allocated at the same time.
 Normally you can just use the parent handle, and things like FSOUND_SetVolume will affect all subchannels at the same time. With this function, you can get access to the raw subchannels to allow manipulation of each voice seperately within the multichannel array.
 For example, a 8 sounds/streams can be interleaved into a multichannel FSB. If you specified a subchannel of 7, it would return a channel handle to the last channel in the multichannel array.
 A subchannel index of 0 is the parent channel, and the same as the voice passed in is a parameter.
 The number of subchannels within a multichannel voice can be determined with FSOUND_GetNumSubChannels.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The value returned by FSOUND_Stream_Play, FSOUND_Stream_PlayEx, FSOUND_PlaySound, FSOUND_PlaySoundEx.<DD><CODE>subchannel</CODE> - Offset from the parent channel into the multichannel array.
<DT><B>Returns:</B><DD>On success, a raw channel handle is returned. On failure, -1 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_GetSurround(int)"><!-- --></A><H3>
FSOUND_GetSurround</H3>
<PRE>
public static int <B>FSOUND_GetSurround</B>(int&nbsp;channel)</PRE>
<DL>
<DD>Returns the surround sound status of the specified channel.
 <p>
 <b>Remarks</b>
 Surround sound only works on software channels.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel number/handle to get the surround sound status from
<DT><B>Returns:</B><DD>On success, TRUE is returned meaning the channel has surround sound turned ON
 On failure, FALSE is returned meaning the channel has surround sound turned OFF</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_IsPlaying(int)"><!-- --></A><H3>
FSOUND_IsPlaying</H3>
<PRE>
public static boolean <B>FSOUND_IsPlaying</B>(int&nbsp;channel)</PRE>
<DL>
<DD>Returns if the channel is currently playing or not.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - Channel number/handle to get the playing status from.
<DT><B>Returns:</B><DD>TRUE channel is currently active and playing. FALSE channel is currently idle.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_3D_GetAttributes(int, java.nio.FloatBuffer, java.nio.FloatBuffer)"><!-- --></A><H3>
FSOUND_3D_GetAttributes</H3>
<PRE>
public static boolean <B>FSOUND_3D_GetAttributes</B>(int&nbsp;channel,
                                              java.nio.FloatBuffer&nbsp;pos,
                                              java.nio.FloatBuffer&nbsp;vel)</PRE>
<DL>
<DD><p>
 <b>Remarks</b>
 A 'distance unit' is specified by FSOUND_3D_SetDistanceFactor. By default this is set to meters which is a distance scale of 1.0. 
 See FSOUND_3D_SetDistanceFactor for more on this.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - Channel you want to get 3d information from<DD><CODE>pos</CODE> - Pointer to a position vector (xyz float triplet) of the emitter in world space, measured in distance units.
 This can be NULL to ignore it.<DD><CODE>vel</CODE> - Pointer to a velocity vector (xyz float triplet), of the emitter measured in distance units PER SECOND.
 This can be NULL to ignore it.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_3D_GetMinMaxDistance(int, java.nio.FloatBuffer)"><!-- --></A><H3>
FSOUND_3D_GetMinMaxDistance</H3>
<PRE>
public static boolean <B>FSOUND_3D_GetMinMaxDistance</B>(int&nbsp;channel,
                                                  java.nio.FloatBuffer&nbsp;minmax)</PRE>
<DL>
<DD>Returns the current min and max distance for a channel
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - Channel number/handle to retrieve min and max distance from.<DD><CODE>minmax</CODE> - FloatBuffer to store min/max -distance.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_3D_Listener_GetAttributes(java.nio.FloatBuffer, java.nio.FloatBuffer, java.nio.FloatBuffer, java.nio.FloatBuffer, java.nio.FloatBuffer, java.nio.FloatBuffer, java.nio.FloatBuffer, java.nio.FloatBuffer)"><!-- --></A><H3>
FSOUND_3D_Listener_GetAttributes</H3>
<PRE>
public static void <B>FSOUND_3D_Listener_GetAttributes</B>(java.nio.FloatBuffer&nbsp;pos,
                                                    java.nio.FloatBuffer&nbsp;vel,
                                                    java.nio.FloatBuffer&nbsp;fx,
                                                    java.nio.FloatBuffer&nbsp;fy,
                                                    java.nio.FloatBuffer&nbsp;fz,
                                                    java.nio.FloatBuffer&nbsp;tx,
                                                    java.nio.FloatBuffer&nbsp;ty,
                                                    java.nio.FloatBuffer&nbsp;tz)</PRE>
<DL>
<DD>This retreives the position, velocity and orientation of a 3d sound listener
 <p>
 <b>Remarks</b>
 FSOUND treats +X as right, +Y as up, and +Z as forwards. (left handed)
 To map to your own coordinate system, flip and exchange these values. For example if you wanted to use right handed coordinates, you would negate the Z value of your own direction vector.
 Orientation vectors are expected to be of UNIT length. This means the magnitude of the vector should be 1.0f.
 ---------
 A 'distance unit' is specified by FSOUND_3D_SetDistanceFactor. By default this is set to meters which is a distance scale of 1.0. 
 See FSOUND_3D_SetDistanceFactor for more on this.
 ---------
 Please remember to use units PER SECOND, NOT PER FRAME as this is a common mistake. 
 Do not just use (pos - lastpos) from the last frame's data for velocity, as this is not correct. 
 You need to time compensate it so it is given in units per SECOND.
 You could alter your pos - lastpos calculation to something like this. 
 vel = (pos-lastpos) / (time taken since last frame in seconds). 
 I.e. at 60fps the formula would look like this 
 vel = (pos-lastpos) / 0.0166667.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pos</CODE> - Pointer to a position vector (xyz float triplet), of the listener in world space, 
 measured in distance units.
 This can be NULL to ignore it.<DD><CODE>vel</CODE> - Pointer to a velocity vector (xyz float triplet), of the listener measured in 
 distance units PER SECOND.
 This can be NULL to ignore it.<DD><CODE>fx</CODE> - pointer to x component of a FORWARD unit length orientation vector
 This can be NULL to ignore it.<DD><CODE>fy</CODE> - pointer to y component of a FORWARD unit length orientation vector
 This can be NULL to ignore it.<DD><CODE>fz</CODE> - pointer to z component of a FORWARD unit length orientation vector
 This can be NULL to ignore it.<DD><CODE>tx</CODE> - pointer to x component of a TOP or upwards facing unit length orientation vector
 This can be NULL to ignore it.<DD><CODE>ty</CODE> - pointer to y component of a TOP or upwards facing unit length orientation vector
 This can be NULL to ignore it.<DD><CODE>tz</CODE> - pointer to z component of a TOP or upwards facing unit length orientation vector
 This can be NULL to ignore it.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_3D_Listener_SetAttributes(java.nio.FloatBuffer, java.nio.FloatBuffer, float, float, float, float, float, float)"><!-- --></A><H3>
FSOUND_3D_Listener_SetAttributes</H3>
<PRE>
public static void <B>FSOUND_3D_Listener_SetAttributes</B>(java.nio.FloatBuffer&nbsp;pos,
                                                    java.nio.FloatBuffer&nbsp;vel,
                                                    float&nbsp;fx,
                                                    float&nbsp;fy,
                                                    float&nbsp;fz,
                                                    float&nbsp;tx,
                                                    float&nbsp;ty,
                                                    float&nbsp;tz)</PRE>
<DL>
<DD>This updates the position, velocity and orientation of a 3d sound listener
 <p>
 <b>Remarks</b>
 FSOUND treats +X as right, +Y as up, and +Z as forwards. (left handed)
 To map to your own coordinate system, flip and exchange these values. For example if you wanted to use
 right handed coordinates, you would negate the Z value of your own direction vector.
 Orientation vectors are expected to be of UNIT length. This means the magnitude of the vector
 should be 1.0f.
 ---------
 A 'distance unit' is specified by FSOUND_3D_SetDistanceFactor. By default this is set to meters which is a distance scale of 1.0. 
 See FSOUND_3D_SetDistanceFactor for more on this.
 ---------
 Please remember to use units PER SECOND, NOT PER FRAME as this is a common mistake. 
 Do not just use (pos - lastpos) from the last frame's data for velocity, as this is not 
 correct. You need to time compensate it so it is given in units per SECOND.
 You could alter your pos - lastpos calculation to something like this. 
 vel = (pos-lastpos) / (time taken since last frame in seconds). Ie at 60fps the formula
 would look like this vel = (pos-lastpos) / 0.0166667.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>pos</CODE> - Pointer to a position vector (xyz float triplet), of the listener in world space, measured in distance units.
 This can be NULL to ignore it.<DD><CODE>vel</CODE> - Pointer to a velocity vector (xyz float triplet), of the listener measured in distance units PER SECOND.
 This can be NULL to ignore it.<DD><CODE>fx</CODE> - x component of a FORWARD unit length orientation vector<DD><CODE>fy</CODE> - y component of a FORWARD unit length orientation vector<DD><CODE>fz</CODE> - z component of a FORWARD unit length orientation vector<DD><CODE>tx</CODE> - x component of a TOP or upwards facing unit length orientation vector<DD><CODE>ty</CODE> - y component of a TOP or upwards facing unit length orientation vector<DD><CODE>tz</CODE> - z component of a TOP or upwards facing unit length orientation vector</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_3D_Listener_SetCurrent(int, int)"><!-- --></A><H3>
FSOUND_3D_Listener_SetCurrent</H3>
<PRE>
public static void <B>FSOUND_3D_Listener_SetCurrent</B>(int&nbsp;current,
                                                 int&nbsp;numlisteners)</PRE>
<DL>
<DD>Sets the current listener number and number of listeners, if the user wants to simulate multiple listeners at once. 
 This is usually for the case in a game where there is a splitscreen and multiple players playing the game at once
 <p>
 <b>Remarks</b>
 Only affects FSOUND_3D_Listener_SetAttributes and FSOUND_3D_Listener_GetAttributes.
 Setting more than 1 listener will turn off doppler and cause all panning to be ignored and 3d sound will come from the center (mono).
 -------------
 For WIN32 FSOUND_HW3D based sounds, channels must have their attributes set after this function is called, otherwise unexpected audible results may occur.
 For example you cannot update your channels with FSOUND_3D_SetAttributes, call FSOUND_3D_Listener_SetCurrent, and then call FSOUND_Update and expect all the voices to update correctly. 
 The correct order is to call FSOUND_3D_Listener_SetCurrent first, then update all channels with FSOUND_3D_SetAttributes, then call FSOUND_Update. 
 This is due to DirectSound not supporting multiple listeners, so FMOD has to do inverse transforms on the positions to simulate it with one listener, at the time FSOUND_3D_SetAttributes is called.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>current</CODE> - Current listener number. Listener commands following this function call will affect this listener number. (default: 0)<DD><CODE>numlisteners</CODE> - Number of listeners active. (default: 1)</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_3D_SetDistanceFactor(float)"><!-- --></A><H3>
FSOUND_3D_SetDistanceFactor</H3>
<PRE>
public static void <B>FSOUND_3D_SetDistanceFactor</B>(float&nbsp;scale)</PRE>
<DL>
<DD>Sets FMOD's 3d engine relative distance factor, compared to 1.0 meters. It equates to 
 'how many units per meter' does your engine have
 <p>
 <b>Remarks</b>
 By default this value is set at 1.0, or meters
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>scale</CODE> - 1.0 = 1 meter units. If you are using feet then scale would equal 3.28.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_3D_SetDopplerFactor(float)"><!-- --></A><H3>
FSOUND_3D_SetDopplerFactor</H3>
<PRE>
public static void <B>FSOUND_3D_SetDopplerFactor</B>(float&nbsp;scale)</PRE>
<DL>
<DD>Sets the doppler shift scale factor. 
 <p>
 <b>Remarks</b>
 This is a general scaling factor for how much the pitch varies due to doppler shifting.
 Increasing the value above 1.0 exaggerates the effect, whereas lowering it reduces the effect.
 0 removes the effect all together.
 FMOD's speed of sound at a DopplerFactor of 1.0 is 340 m/s.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>scale</CODE> - Doppler shift scale. Default value for FSOUND is 1.0f</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_3D_SetRolloffFactor(float)"><!-- --></A><H3>
FSOUND_3D_SetRolloffFactor</H3>
<PRE>
public static void <B>FSOUND_3D_SetRolloffFactor</B>(float&nbsp;rolloff)</PRE>
<DL>
<DD>Sets the global attenuation rolloff factor.
 Normally volume for a sample will scale at 1 / distance. This gives a logarithmic attenuation of volume as the source gets further away (or closer).
 Setting this value makes the sound drop off faster or slower. The higher the value, the faster volume will fall off. 
 The lower the value, the slower it will fall off.
 For example a rolloff factor of 1 will simulate the real world, where as a value of 2 will make sounds attenuate 2 times quicker
 <p>
 <b>Remarks</b>
 ---------
 A 'distance unit' is specified by FSOUND_3D_SetDistanceFactor. 
 By default this is set to meters which is a distance scale of 1.0. 
 See FSOUND_3D_SetDistanceFactor for more on this.
 ---------
 The default rolloff factor is 1.0.   
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rolloff</CODE> - The rolloff factor to set for this sample. Valid ranges are 0 to 10.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_Open(java.lang.String, int, int, int)"><!-- --></A><H3>
FSOUND_Stream_Open</H3>
<PRE>
public static <A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A> <B>FSOUND_Stream_Open</B>(java.lang.String&nbsp;name,
                                              int&nbsp;mode,
                                              int&nbsp;offset,
                                              int&nbsp;length)</PRE>
<DL>
<DD>Opens an audio file/url/cd ready for streaming. 
 This opens the file in preparation for playback in real-time, without needing to decode the whole file into memory first
 <p>
 <b>Remarks</b>
 WAV support supports windows codec compressed WAV files.
 --------------
 FSOUND_MPEGACCURATE is to be used cautiously. To open a file with this mode turned on, it has to scan the whole MP3 first. This can take several seconds if the file is big, or the harddisk/cpu is slow.
 A way to speed up this process would be to load the compressed mp3 into memory first, and use the FSOUND_LOADMEMORY flag with this function.
 --------------
 NOTE : Internet stream limitations
 - URLs must start with "http://".
 - The only supported formats for HTTP streams are MP3 (must have .mp3 extension) and OggVorbis (must have .ogg extension).
 --------------
 FSB streaming is not supported if the format from FSBank is 'Retain original format'. On PC platforms, only PCM and ADPCM FSB files are allowed.
 --------------
 Note, on PlayStation 2 you cannot use FSOUND_LOADMEMORY, you may use FSOUND_LOADMEMORYIOP though.
 --------------
 When opening with the FSOUND_NONBLOCKING flag, this function always succeeds at the point of being called. 
 It will always return a valid channel handle, even though the file might fail to open. To determine any error in non blocking mode use FSOUND_Stream_GetOpenState.
 --------------
 NOTE: CDDA Streaming (Win32 only!)
 To open a CD for CDDA streaming, specify the drive letter of a CD drive e.g. FSOUND_Stream_Open("d:", 0, 0, 0); FSOUND_Stream_Open will create a stream with multiple substreams, one for each CD track. Use FSOUND_Stream_SetSubStream to select which CD track to play.
 A number of options can be passed to FSOUND_Stream_Open along with the drive letter. They are :
 ? e.g. FSOUND_Stream_Open("d:*?", 0, 0, 0); This option will cause a tag field called "CD_DEVICE_INFO" to be attached to the stream. This tag field contains information on the specified CD device.
 ! e.g. FSOUND_Stream_Open("d:*!", 0, 0, 0); This option will cause the stream to be opened in "quick open" mode. When a stream is opened in this mode, calls to FSOUND_Stream_SetSubStream will return immediately making it quick to select each substream in turn and get the length of each CD track. Note that a stream in quick open mode cannot be played! Use quick open mode to get track lengths and then re-open the stream without quick open mode to actually play it.
 j e.g. FSOUND_Stream_Open("d:*j", 0, 0, 0); This option turns jitter correction OFF.
 Options can be combined like so: FSOUND_Stream_Open("d:*?!j", 0, 0, 0);
 If a nonblocking CDDA stream fails to open, a tag field called "CD_ERROR" will be attached to the stream. This tag field contains a textual description of why the stream failed to open.
 NOTE: FMOD will always try to use native NTSCSI support to communicate with CD devices before trying to use ASPI. If FMOD is using ASPI then it can only access the first CD device it finds.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>name</CODE> - Name of the file to open, or pointer to data if FSOUND_LOADMEMORY is used.<DD><CODE>mode</CODE> - Simple description of how to play the file. For all formats except raw PCM,
 FSOUND_LOOP*, FSOUND_HW3D, FSOUND_HW2D, FSOUND_2D, FSOUND_LOADMEMORY, FSOUND_LOADRAW, FSOUND_MPEGACCURATE, FSOUND_NONBLOCKING flags are the only ones supported.<DD><CODE>offset</CODE> - Optional. 0 by default. If > 0, this value is used to specify an offset in a file, so fmod will seek before opening. length must also be specified if this value is used.<DD><CODE>length</CODE> - Optional. 0 by default. If > 0, this value is used to specify the length of a memory block when using FSOUND_LOADMEMORY, or it is the length of a file or file segment if the offset parameter is used. On PlayStation 2 this must be 16 byte aligned for memory loading.
<DT><B>Returns:</B><DD>On success, a reference to an opened stream is returned. On failure, NULL is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_Open(java.nio.ByteBuffer, int)"><!-- --></A><H3>
FSOUND_Stream_Open</H3>
<PRE>
public static <A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A> <B>FSOUND_Stream_Open</B>(java.nio.ByteBuffer&nbsp;data,
                                              int&nbsp;mode)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>data</CODE> - data when FSOUND_LOADMEMORY is used.<DD><CODE>mode</CODE> - Simple description of how to play the file. For all formats except raw PCM,
 FSOUND_LOOP*, FSOUND_HW3D, FSOUND_HW2D, FSOUND_2D, FSOUND_LOADMEMORY, FSOUND_LOADRAW, FSOUND_MPEGACCURATE, FSOUND_NONBLOCKING flags are the only ones supported.
<DT><B>Returns:</B><DD>On success, a reference to an opened stream is returned. On failure, NULL is returned.<DT><B>See Also:</B><DD><A HREF="../../../org/lwjgl/fmod3/FSound.html#FSOUND_Stream_Open(java.lang.String, int, int, int)"><CODE>FSOUND_Stream_Open(String, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_Play(int, org.lwjgl.fmod3.FSoundStream)"><!-- --></A><H3>
FSOUND_Stream_Play</H3>
<PRE>
public static int <B>FSOUND_Stream_Play</B>(int&nbsp;channel,
                                     <A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</PRE>
<DL>
<DD>Starts a pre-opened stream playing
 <p>
 <b>Remarks</b>
 When a stream starts to play, it inherits a special high priority (256). 
 It cannot be rejected by other sound effect channels in the normal fashion as the user can never set a priority above 255 normally. 
 --------------
 If the stream has been opened with FSOUND_NONBLOCKING, this function will not succeed until the stream is ready.
 --------------
 FSB streaming is not supported if the format from FSBank is 'Retain original format'. On PC platforms, only PCM and ADPCM FSB files are allowed.
 --------------
 FSOUND_STEREOPAN is recommended for stereo streams if you call FSOUND_SetPan. This puts the left and right channel to full volume.
 Otherwise a normal pan will give half volume for left and right. See FSOUND_SetPan for more information on this.
 --------------
 You can use normal channel based commands (such as FSOUND_SetVolume etc) on the return handle, as it is a channel handle.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - 0+ The channel index in the channel pool. This must not exceed the maximum number of channels allocated with FSOUND_Init 
 FSOUND_FREE
 Chooses a free channel to play in. If all channels are used then it
 selects a channel with a sample playing that has a lower priority than the 
 sample to be played.<DD><CODE>stream</CODE> - FSoundStream to be played.
<DT><B>Returns:</B><DD>On success, the channel handle the stream is playing in is returned. On failure, -1 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_Stop(org.lwjgl.fmod3.FSoundStream)"><!-- --></A><H3>
FSOUND_Stream_Stop</H3>
<PRE>
public static boolean <B>FSOUND_Stream_Stop</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</PRE>
<DL>
<DD>Stops a stream from playing
 <p>
 <b>Remarks</b>
 The stream is still prepared and sitting in memory ready to go. Use FSOUND_Stream_Close on the stream to completely remove it.
 If the stream has been opened with FSOUND_NONBLOCKING, this function will not succeed until the stream is ready
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - FSoundStream to be stopped
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_Close(org.lwjgl.fmod3.FSoundStream)"><!-- --></A><H3>
FSOUND_Stream_Close</H3>
<PRE>
public static boolean <B>FSOUND_Stream_Close</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</PRE>
<DL>
<DD>Shuts down and releases an FSOUND stream
 <p>
 <b>Remarks</b>
 If the stream has been opened with FSOUND_NONBLOCKING, this function will not succeed until the stream is ready.
 The only exception to this rule is for internet streams - this function will successfully close an internet stream that has been opened with FSOUND_NONBLOCKING before that stream is ready.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - FSoundStream to be closed
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_GetNumSubStreams(org.lwjgl.fmod3.FSoundStream)"><!-- --></A><H3>
FSOUND_Stream_GetNumSubStreams</H3>
<PRE>
public static int <B>FSOUND_Stream_GetNumSubStreams</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</PRE>
<DL>
<DD>Returns the number of substreams inside a multi-stream FSB bank file
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - FSoundStream to get substream count from
<DT><B>Returns:</B><DD>On success, the number of FSB substreams is returned. On failure, 0 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_SetSubStream(org.lwjgl.fmod3.FSoundStream, int)"><!-- --></A><H3>
FSOUND_Stream_SetSubStream</H3>
<PRE>
public static int <B>FSOUND_Stream_SetSubStream</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                             int&nbsp;index)</PRE>
<DL>
<DD>Seeks a stream to the substream inside a multi-stream FSB bank file, specified by its index
 <p>
 <b>Remarks</b>
 A stream will stop if this function is called, as it needs to seek and flush the buffer.
 Indicies for this function are generated as user friendly constants when compiling the FSB bank, and are available in the relevant generated header file.
 --------------
 If the stream has been opened with FSOUND_NONBLOCKING, this function will ALWAYS succeed, but puts the stream back into a non-ready state. You then have to poll after calling this to make sure the stream is ready.
 You can either do this by calling FSOUND_Stream_Play repeatedly/once a frame until it is succeeds, or FSOUND_Stream_GetOpenState.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - to have its position set<DD><CODE>index</CODE> - The index of the stream within the FSB file
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_AddSyncPoint(org.lwjgl.fmod3.FSoundStream, int, java.lang.String)"><!-- --></A><H3>
FSOUND_Stream_AddSyncPoint</H3>
<PRE>
public static <A HREF="../../../org/lwjgl/fmod3/FSoundSyncPoint.html" title="class in org.lwjgl.fmod3">FSoundSyncPoint</A> <B>FSOUND_Stream_AddSyncPoint</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                                         int&nbsp;pcmoffset,
                                                         java.lang.String&nbsp;name)</PRE>
<DL>
<DD>Adds a user synchronization callback point into a stream
 <p>
 <b>Remarks</b>
 If the stream has been opened with FSOUND_NONBLOCKING, this function will not succeed until the stream is ready   
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - The stream to add a sync point to.<DD><CODE>pcmoffset</CODE> - Offset in SAMPLES (not bytes).<DD><CODE>name</CODE> - The name of the syncpoint, which will be passed into the sync callback when it is triggered.
<DT><B>Returns:</B><DD>On success, a sync point handle is returned. On failure, NULL is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_Create(org.lwjgl.fmod3.callbacks.FSoundStreamCallback, int, int, int)"><!-- --></A><H3>
FSOUND_Stream_Create</H3>
<PRE>
public static <A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A> <B>FSOUND_Stream_Create</B>(<A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundStreamCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundStreamCallback</A>&nbsp;callbackHandler,
                                                int&nbsp;lenbytes,
                                                int&nbsp;mode,
                                                int&nbsp;samplerate)</PRE>
<DL>
<DD>Creates a user definable stream file ready for playing. The stream is serviced through a callback
 <p>
 <b>Remarks</b>
 This method only supports SIGNED RAW streams to be written to the buffer supplied by the callback. 
 They can be 8 or 16 bit, mono or stereo.
 'lenbytes' may be rounded down to the nearest sample alignment in bytes. Ie if you specified 1001 bytes for a 16bit stereo sample stream, len would return 1000 in the callback. (250 samples * 4 bytes per sample)
 PlayStation 2 IMPORTANT! : if FSOUND_SendData is NOT called from the stream callback the IOP will hang because it is waiting for this command to be executed before it can unlock its buffer.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>callbackHandler</CODE> - FSoundStreamCallback to be called back<DD><CODE>lenbytes</CODE> - Size of the data in BYTES the callback will require to be written to the buffer.<DD><CODE>mode</CODE> - Description of the raw sample data being opened. see FSOUND_MODES for a description of these modes.<DD><CODE>samplerate</CODE> - Rate of playback. Be careful you dont set the sample rate too high so that the stream servicer (ie the harddisk) may not keep up.
<DT><B>Returns:</B><DD>On success, a sync point handle is returned. On failure, NULL is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_CreateDSP(org.lwjgl.fmod3.FSoundStream, org.lwjgl.fmod3.callbacks.FSoundDSPCallback, int)"><!-- --></A><H3>
FSOUND_Stream_CreateDSP</H3>
<PRE>
public static <A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A> <B>FSOUND_Stream_CreateDSP</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                                    <A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundDSPCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundDSPCallback</A>&nbsp;callback,
                                                    int&nbsp;priority)</PRE>
<DL>
<DD>Allows the user to add a custom DSP unit to a stream
 <p>
 <b>Remarks</b>
 The priority for a stream DSP unit is not related to the priorities specified in fmod.h.
 The priorities are anything fom 0 onwards, and ALWAYS come after data is read/decoded for the stream   * </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - The stream to have a DSP attached to.<DD><CODE>callback</CODE> - A standard FSoundDSPCallback callback<DD><CODE>priority</CODE> - The priority, or position within the streams DSP chain to place the unit.
<DT><B>Returns:</B><DD>On success, a handle to the FSoundDSPUnit is returned. All DSP functions are performable on this. On failure, null is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_DeleteSyncPoint(org.lwjgl.fmod3.FSoundSyncPoint)"><!-- --></A><H3>
FSOUND_Stream_DeleteSyncPoint</H3>
<PRE>
public static boolean <B>FSOUND_Stream_DeleteSyncPoint</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSyncPoint.html" title="class in org.lwjgl.fmod3">FSoundSyncPoint</A>&nbsp;point)</PRE>
<DL>
<DD>Removes a user synchronization callback point from a stream.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>point</CODE> - The sync point to remove
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_FindTagField(org.lwjgl.fmod3.FSoundStream, org.lwjgl.fmod3.FSoundTagField)"><!-- --></A><H3>
FSOUND_Stream_FindTagField</H3>
<PRE>
public static boolean <B>FSOUND_Stream_FindTagField</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                                 <A HREF="../../../org/lwjgl/fmod3/FSoundTagField.html" title="class in org.lwjgl.fmod3">FSoundTagField</A>&nbsp;field)</PRE>
<DL>
<DD>Find a tag field associated with an open stream by name and type
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - The stream to get the tag field from.<DD><CODE>field</CODE> - FSoundTagField to find (using type, name)
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_GetLength(org.lwjgl.fmod3.FSoundStream)"><!-- --></A><H3>
FSOUND_Stream_GetLength</H3>
<PRE>
public static int <B>FSOUND_Stream_GetLength</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</PRE>
<DL>
<DD>Returns the size of the stream in BYTES
 <p>
 <b>Remarks</b>
 Position functions for streams work in bytes not samples.
 -----
 This function is not supported for URL based streams over the internet.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - The stream to have its length returned
<DT><B>Returns:</B><DD>On success, the size of the stream in BYTES is returned. On failure, 0 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_GetLengthMs(org.lwjgl.fmod3.FSoundStream)"><!-- --></A><H3>
FSOUND_Stream_GetLengthMs</H3>
<PRE>
public static int <B>FSOUND_Stream_GetLengthMs</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</PRE>
<DL>
<DD>Returns the size of the stream in MILLISECONDS
 <p>
 <b>Remarks</b>
 FSOUND_MPEGACCURATE will need to be used with mp3 files that use VBR encoding for more accuracy
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - The stream to have its its total duration returned.
<DT><B>Returns:</B><DD>On success, the size of the stream in MILLISECONDS is returned. On failure, 0 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_GetMode(org.lwjgl.fmod3.FSoundStream)"><!-- --></A><H3>
FSOUND_Stream_GetMode</H3>
<PRE>
public static int <B>FSOUND_Stream_GetMode</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</PRE>
<DL>
<DD>Retrieves the mode of the stream
 <p>
 <b>Remarks</b>
 If the stream has been opened with FSOUND_NONBLOCKING, this function will not succeed until the stream is ready.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - The stream to get the mode from
<DT><B>Returns:</B><DD>mode of stream</DL>
</DD>
</DL>
<HR>

<A NAME="nFSOUND_Stream_GetNumSyncPoints(org.lwjgl.fmod3.FSoundStream)"><!-- --></A><H3>
nFSOUND_Stream_GetNumSyncPoints</H3>
<PRE>
public static int <B>nFSOUND_Stream_GetNumSyncPoints</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</PRE>
<DL>
<DD>Returns the number of substreams inside a multi-stream FSB bank file
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - stream to query
<DT><B>Returns:</B><DD>On success, the number of FSB substreams is returned. On failure, 0 is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_GetNumTagFields(org.lwjgl.fmod3.FSoundStream, java.nio.IntBuffer)"><!-- --></A><H3>
FSOUND_Stream_GetNumTagFields</H3>
<PRE>
public static boolean <B>FSOUND_Stream_GetNumTagFields</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                                    java.nio.IntBuffer&nbsp;num)</PRE>
<DL>
<DD>Get the number of tag fields associated with the specified stream
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - stream to query<DD><CODE>num</CODE> - IntBuffer that will receive the nubmer of tag fields associated with the specified stream.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_GetOpenState(org.lwjgl.fmod3.FSoundStream)"><!-- --></A><H3>
FSOUND_Stream_GetOpenState</H3>
<PRE>
public static int <B>FSOUND_Stream_GetOpenState</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</PRE>
<DL>
<DD>If a stream is opened with FSOUND_NONBLOCKING, this function returns the state of the opening stream
 <p>
 <b>Remarks</b>
 A blocking stream will return NULL from FSOUND_Stream_Open so a return value of -3 is redundant in this case.
 A blocking stream will always return 0 if it is not NULL.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - to get the open state from.
<DT><B>Returns:</B><DD>0 = stream is opened and ready. 
 -1 = stream handle passed in is invalid.
 -2 = stream is still opening or performing a SetSubStream command.
 -3 = stream failed to open. (file not found, out of memory or other error).
 -4 = connecting to remote host (internet streams only)
 -5 = stream is buffering data (internet streams only)</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_GetPosition(org.lwjgl.fmod3.FSoundStream)"><!-- --></A><H3>
FSOUND_Stream_GetPosition</H3>
<PRE>
public static int <B>FSOUND_Stream_GetPosition</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</PRE>
<DL>
<DD>Returns the current FILE position of the stream of the stream in BYTES
 <p>
 <b>Remarks</b>
 Position functions for streams work in bytes not samples.
 Position information is also based on the current file position, not the actual playing
 position, so if the stream is only updated every 100ms, then the position will only be
 updated every 100ms.
 -----
 This function is not supported for URL based streams over the internet or CDDA streams
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - to have its position returned
<DT><B>Returns:</B><DD>On success, the current stream's position in BYTES is returned. On failure, 0 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_GetSample(org.lwjgl.fmod3.FSoundStream)"><!-- --></A><H3>
FSOUND_Stream_GetSample</H3>
<PRE>
public static <A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A> <B>FSOUND_Stream_GetSample</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</PRE>
<DL>
<DD>Returns the FSOUND_SAMPLE definition that the stream uses internally. 
 You can use this to get a variety of information like the songs name, default speed and more.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - to have its internal sample pointer returned.
<DT><B>Returns:</B><DD>On success, a handle to the FSOUND_SAMPLE definition is returned. On failure, 0 is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_GetSyncPoint(org.lwjgl.fmod3.FSoundStream, int)"><!-- --></A><H3>
FSOUND_Stream_GetSyncPoint</H3>
<PRE>
public static <A HREF="../../../org/lwjgl/fmod3/FSoundSyncPoint.html" title="class in org.lwjgl.fmod3">FSoundSyncPoint</A> <B>FSOUND_Stream_GetSyncPoint</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                                         int&nbsp;index)</PRE>
<DL>
<DD>Obtains a sync point by index. This is useful when you havent created your own, ie it came from a wav file
 <p>
 <b>Remarks</b>
 Points are loaded in order of offset, so the index will represent the smallest point to the largest.   * </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - to have its position returned<DD><CODE>index</CODE> - The sync point offset into the stream
<DT><B>Returns:</B><DD>On success, a handle to a sync point is returned. On failure, NULL is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_GetSyncPointInfo(org.lwjgl.fmod3.FSoundSyncPoint, java.nio.IntBuffer)"><!-- --></A><H3>
FSOUND_Stream_GetSyncPointInfo</H3>
<PRE>
public static java.lang.String <B>FSOUND_Stream_GetSyncPointInfo</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSyncPoint.html" title="class in org.lwjgl.fmod3">FSoundSyncPoint</A>&nbsp;point,
                                                              java.nio.IntBuffer&nbsp;pcmoffset)</PRE>
<DL>
<DD>Retrieves the name and pcm offset in samples for a specified sync point
 <p>
 <b>Remarks</b>
 Convert samples to time by dividing the PCM value by the default samplerate. This would give you the value in seconds. Multiply by 1000 to get milliseconds.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>point</CODE> - handle to the sync point to retrieve information from<DD><CODE>pcmoffset</CODE> - An IntBuffer that will receive the sync point offset in pcm SAMPLES. A value of NULL will be ignored
<DT><B>Returns:</B><DD>On success, the name of the syncpoint is returned as a string. On failure, NULL is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_GetTagField(org.lwjgl.fmod3.FSoundStream, int, org.lwjgl.fmod3.FSoundTagField)"><!-- --></A><H3>
FSOUND_Stream_GetTagField</H3>
<PRE>
public static boolean <B>FSOUND_Stream_GetTagField</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                                int&nbsp;num,
                                                <A HREF="../../../org/lwjgl/fmod3/FSoundTagField.html" title="class in org.lwjgl.fmod3">FSoundTagField</A>&nbsp;field)</PRE>
<DL>
<DD>Get a tag field associated with an open stream
 <p>
 <b>Remarks</b>
 If this function returns successfully, "value" will contain a pointer to a piece of tag-field-specific data - do not assume it will always point to a null-terminated ASCII string.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - The stream to get the tag field from.<DD><CODE>num</CODE> - The number of the tag field to retrieve.<DD><CODE>field</CODE> - TagField to receive data
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_GetTime(org.lwjgl.fmod3.FSoundStream)"><!-- --></A><H3>
FSOUND_Stream_GetTime</H3>
<PRE>
public static int <B>FSOUND_Stream_GetTime</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream)</PRE>
<DL>
<DD>Returns the current time offset in stream in milliseconds.
 <p>
 <b>Remarks</b>
 FSOUND_MPEGACCURATE will need to be used with mp3 files that use VBR encoding for more accuracy
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - to get the currently playing time offset
<DT><B>Returns:</B><DD>On success, the current stream's position in milliseconds is returned. On failure, 0 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_Net_GetBufferProperties(java.nio.IntBuffer)"><!-- --></A><H3>
FSOUND_Stream_Net_GetBufferProperties</H3>
<PRE>
public static boolean <B>FSOUND_Stream_Net_GetBufferProperties</B>(java.nio.IntBuffer&nbsp;values)</PRE>
<DL>
<DD>Gets buffer size and thresholds that will be used when opening new internet streams
 <p>
 <b>Remarks</b>
 This function returns the values that will be used for subsequent internet stream opens. Internet streams that already exist may have different values.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>values</CODE> - IntBuffer to hold 3 int values:
 buffersize size in bytes of the streaming buffer.
 prebuffer_percent how much to prebuffer when a stream is first opened. Values are expressed as a percentage from 1 to 99.
 rebuffer_percent how much to rebuffer after a stream has suffered a buffer underrun. Values are expressed as a percentage from 1 to 99.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_Net_GetLastServerStatus()"><!-- --></A><H3>
FSOUND_Stream_Net_GetLastServerStatus</H3>
<PRE>
public static java.lang.String <B>FSOUND_Stream_Net_GetLastServerStatus</B>()</PRE>
<DL>
<DD>This function returns a String representing the last HTTP status line that was received when connecting to an internet stream
 <p>
 <b>Remarks</b>
 The result of this function should be used for informational purposes only. 
 This function provides no facility to discover which internet stream the last HTTP status pertains to when there are multiple internet streams open.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>last HTTP status line that was received</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_Net_GetStatus(org.lwjgl.fmod3.FSoundStream, java.nio.IntBuffer)"><!-- --></A><H3>
FSOUND_Stream_Net_GetStatus</H3>
<PRE>
public static boolean <B>FSOUND_Stream_Net_GetStatus</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                                  java.nio.IntBuffer&nbsp;values)</PRE>
<DL>
<DD>Get various status information for an internet stream
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - to get status information on<DD><CODE>values</CODE> - IntBuffer to hold 4 int values:
 status variable that will receive a status value. See FSOUND_STREAM_NET_STATUS.
 bufferused variable that will receive the percentage of the read buffer that is currently in use.
 bitrate variable that will receive the current bitrate of the stream.
 flags variable that will receive a flags field describing protocol and format information. See FSOUND_STATUS_FLAGS.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_Net_SetBufferProperties(int, int, int)"><!-- --></A><H3>
FSOUND_Stream_Net_SetBufferProperties</H3>
<PRE>
public static boolean <B>FSOUND_Stream_Net_SetBufferProperties</B>(int&nbsp;buffersize,
                                                            int&nbsp;prebuffer_percent,
                                                            int&nbsp;rebuffer_percent)</PRE>
<DL>
<DD>Sets buffer size and thresholds to use when opening new internet streams
 <p>
 <b>Remarks</b>
 Call this function before FSOUND_Stream_Open. This function has no effect on internet streams that are already open
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>buffersize</CODE> - Size in bytes of the streaming buffer. Make it bigger to avoid buffer underruns. (Default = 64000)<DD><CODE>prebuffer_percent</CODE> - How much to prebuffer when a stream is first opened. Values are expressed as a percentage from 1 to 99. (Default = 95)<DD><CODE>rebuffer_percent</CODE> - How much to rebuffer after a stream has suffered a buffer underrun. Values are expressed as a percentage from 1 to 99. (Default = 95)
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_Net_SetMetadataCallback(org.lwjgl.fmod3.FSoundStream, org.lwjgl.fmod3.callbacks.FSoundMetaDataCallback)"><!-- --></A><H3>
FSOUND_Stream_Net_SetMetadataCallback</H3>
<PRE>
public static boolean <B>FSOUND_Stream_Net_SetMetadataCallback</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                                            <A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundMetaDataCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundMetaDataCallback</A>&nbsp;callback)</PRE>
<DL>
<DD>Set a metadata callback for an internet stream
 <p>
 <b>Remarks</b>
 The supplied metadata callback function will be called each time the specified internet stream receives a chunk of metadata.
 Do not do any time-consuming processing in a metadata callback function or network subsystem performance may degrade.
 Do not attempt to modify or free any memory passed to a metadata callback function.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - to set the metadata callback for<DD><CODE>callback</CODE> - metadata callback to attach to this stream
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_Net_SetProxy(java.lang.String)"><!-- --></A><H3>
FSOUND_Stream_Net_SetProxy</H3>
<PRE>
public static boolean <B>FSOUND_Stream_Net_SetProxy</B>(java.lang.String&nbsp;proxy)</PRE>
<DL>
<DD>Set a proxy server to use for all subsequent internet connections
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>proxy</CODE> - The name of a proxy server in host:port format e.g. www.fmod.org:8888 (defaults to port 80 if no port is specified).
 Basic authentication is supported. To use it, this parameter must be in user:password@host:port format e.g. bob:sekrit123@www.fmod.org:8888
 Set this parameter to NULL if no proxy is required
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_PlayEx(int, org.lwjgl.fmod3.FSoundStream, org.lwjgl.fmod3.FSoundDSPUnit, boolean)"><!-- --></A><H3>
FSOUND_Stream_PlayEx</H3>
<PRE>
public static int <B>FSOUND_Stream_PlayEx</B>(int&nbsp;channel,
                                       <A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                       <A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A>&nbsp;dspunit,
                                       boolean&nbsp;paused)</PRE>
<DL>
<DD>Extended featured version of FSOUND_Stream_Play.
 Added functionality includes the ability to start the stream paused. This allows attributes
 of a stream channel to be set freely before the stream actually starts playing, until FSOUND_SetPaused(FALSE) is used.
 Also added is the ability to associate the stream channel to a specified DSP unit. This allows
 the user to 'group' channels into seperate DSP units, which allows effects to be inserted
 between these 'groups', and allow various things like having one group affected by reverb (wet mix) and another group of 
 channels unaffected (dry). This is useful to seperate things like music from being affected
 by DSP effects, while other sound effects are.
 <p>
 <b>Remarks</b>
 When a stream starts to play, it inherits a special high priority (256). 
 It cannot be rejected by other sound effect channels in the normal fashion as the user can never set a priority above 255 normally. 
 --------
 FSOUND_STEREOPAN is recommended for stereo streams if you call FSOUND_SetPan. This puts the left and right channel to full volume.
 Otherwise a normal pan will give half volume for left and right. See FSOUND_SetPan for more information on this.
 --------
 You can use normal channel based commands (such as FSOUND_SetVolume etc) on the return handle, as it is a channel handle.   
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - 0+ The absolute channel number in the channel pool. 
 Remember software channels come first, followed by hardware channels. 
 You cannot play a software sample on a hardware channel and vice versa.
 FSOUND_FREE
 Chooses a free channel to play in. If all channels are used then it
 selects a channel with a sample playing that has an EQUAL or LOWER priority 
 than the sample to be played.<DD><CODE>stream</CODE> - already opened stream to be played<DD><CODE>dspunit</CODE> - dsp unit to attach the channel to<DD><CODE>paused</CODE> - Start the stream paused or not. Pausing the stream channel allows attributes to be set before it is unpaused
<DT><B>Returns:</B><DD>On success, a channel handle the stream is playing in is returned. On failure, -1 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_SetBufferSize(int)"><!-- --></A><H3>
FSOUND_Stream_SetBufferSize</H3>
<PRE>
public static boolean <B>FSOUND_Stream_SetBufferSize</B>(int&nbsp;ms)</PRE>
<DL>
<DD>Sets the internal file buffersize for audio streaming of data for the NEXT stream opened with FSOUND_Stream_Open. 
 Larger values will consume more memory (see remarks), whereas smaller values may be subject to large delays in disk access, especially from CDROM.
 <p>
 <b>Remarks</b>
 The default setting is 200ms. Under Windows CE it is default to 100ms.
 To calculate memory usage for a stream buffer, it is a simple matter of calculating sizebytes = streambuffersize * sample rate / 1000 * (bitdepth / 8) * numchannels * 2, where numchannels is 1 for mono,
 or 2 for stereo files. It is multiplied by 2 because FSOUND stream buffers are double buffers.
 Note this function does not affect user created streams, as the buffer size is specified in FSOUND_Stream_Create.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ms</CODE> - Time in milliseconds between stream updates. FMOD tries to access the disk and 
 decompress data every period specified. Values less than 50 result in an error
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_SetEndCallback(org.lwjgl.fmod3.FSoundStream, org.lwjgl.fmod3.callbacks.FSoundStreamCallback)"><!-- --></A><H3>
FSOUND_Stream_SetEndCallback</H3>
<PRE>
public static boolean <B>FSOUND_Stream_SetEndCallback</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                                   <A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundStreamCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundStreamCallback</A>&nbsp;callback)</PRE>
<DL>
<DD>Sets a callback function for when a stream has ended
 <p>
 <b>Remarks</b>
 Only calls back when a stream stops. (not when a looping stream reaches its end point)
 Note it uses a FSOUND_STREAMCALLBACK function callback. This is normally for user streams but for 
 the sake of re-usability this prototype is used. 'buff' and 'length' are NULL and 0 in this case
 when the callback occurs. The return value can be TRUE or FALSE it is ignored.
 -----------
 If the stream has been opened with FSOUND_NONBLOCKING, this function will not succeed until the stream is ready.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - to set the metadata callback for<DD><CODE>callback</CODE> - FSoundStreamCallback callback to attach to this stream
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_SetLoopCount(org.lwjgl.fmod3.FSoundStream, int)"><!-- --></A><H3>
FSOUND_Stream_SetLoopCount</H3>
<PRE>
public static int <B>FSOUND_Stream_SetLoopCount</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                             int&nbsp;count)</PRE>
<DL>
<DD>Sets the stream to loop the number of times specified by the user. If not called it loops forever
 <p>
 <b>Remarks</b>
 This specifies how many loops, not how many times to play the sound back. Therefore when you specify 0, you will hear the sound once, if you specify 1, you will hear the sound twice, and so on.   
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - already opened stream to be played<DD><CODE>count</CODE> - Number of times to loop. 0 would be similar to having FSOUND_LOOP_OFF set. &gt;0 is infinity
<DT><B>Returns:</B><DD>On success, a channel handle the stream is playing in is returned. On failure, -1 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_SetLoopPoints(org.lwjgl.fmod3.FSoundStream, int, int)"><!-- --></A><H3>
FSOUND_Stream_SetLoopPoints</H3>
<PRE>
public static int <B>FSOUND_Stream_SetLoopPoints</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                              int&nbsp;loopstart,
                                              int&nbsp;loopend)</PRE>
<DL>
<DD>Sets the loop points for a stream
 <p>
 <b>Remarks</b>
 For streams, setting looppoints is reasonably accurate but should not be assumed to be perfectly sample accurate in all cases.
 It depends on the compression format in some cases as seek positions need to be rounded to the nearest compression block offset.
 FSOUND_MPEGACCURATE will need to be used with mp3 files that use VBR encoding for more accuracy.
 You cannot call this function wile the stream is playing, it has to be stopped   
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - already opened stream to be played<DD><CODE>loopstart</CODE> - The start of the loop, specified in PCM SAMPLES.<DD><CODE>loopend</CODE> - The end of the loop, specified in PCM SAMPLES.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_SetMode(org.lwjgl.fmod3.FSoundStream, int)"><!-- --></A><H3>
FSOUND_Stream_SetMode</H3>
<PRE>
public static int <B>FSOUND_Stream_SetMode</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                        int&nbsp;mode)</PRE>
<DL>
<DD>Set a streams mode
 <p>
 <b>Remarks</b>
 If the stream has been opened with FSOUND_NONBLOCKING, this function will not succeed until the stream is ready.
 Only the following modes are accepted, others will be filtered out.
 FSOUND_LOOP_BIDI, FSOUND_LOOP_NORMAL, FSOUND_LOOP_OFF, FSOUND_2D. FSOUND_LOOP_BIDI is treated as FSOUND_LOOP_NORMAL. FSOUND_2D is accepted only if the sound is not hardware.
 On playstation 2, FSOUND_HW3D and FSOUND_HW2D modes are accepted
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - to have the mode set<DD><CODE>mode</CODE> - The mode bits to set from FSOUND_MODES
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_SetPosition(org.lwjgl.fmod3.FSoundStream, int)"><!-- --></A><H3>
FSOUND_Stream_SetPosition</H3>
<PRE>
public static int <B>FSOUND_Stream_SetPosition</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                            int&nbsp;position)</PRE>
<DL>
<DD>Set a streams mode
 <p>
 <b>Remarks</b>
 Position functions for streams talk in bytes and NOT samples.
 The reason for not taking the header into account is people usually want to know the offset to seek to relative to the start of their data (ie as they see it in soundforge or whatever), not from offset 0 which is almost meaningless if you dont know the format.
 --------------
 If the stream has been opened with FSOUND_NONBLOCKING, this function will not succeed until the stream is ready.   * </p>
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - to have its position set<DD><CODE>position</CODE> - Offset in bytes from start of actual sound data (not including any header)
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_SetSubStreamSentence(org.lwjgl.fmod3.FSoundStream, java.nio.IntBuffer)"><!-- --></A><H3>
FSOUND_Stream_SetSubStreamSentence</H3>
<PRE>
public static int <B>FSOUND_Stream_SetSubStreamSentence</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                                     java.nio.IntBuffer&nbsp;sentencelist)</PRE>
<DL>
<DD>This function allows the user to describe the playback order of a list of substreams. The substreams will be played back in order seamlessly.
 <p>
 <b>Remarks</b>
 This feature only works with FSB files that have multiple streams stored within it.
 To remove any sentence, simply call this function with NULL and 0.
 FMOD copies the list from the supplied pointer. Once the pointer is used, the caller can discard the original array.
 This function will fail if the stream is playing. The stream must be stopped for it to work.
 ------------
 If the stream is opened with FSOUND_NONBLOCKING, and the stream is not ready (it is still opening), then this function will return FALSE.
 When it is ready, it will return TRUE, but after this call the stream is put back into a non-ready state, because it is asynchronously seeking again.
 You then have to poll after calling this to make sure the stream is ready.
 You can either do this by calling FSOUND_Stream_Play repeatedly/once a frame until it is succeeds, or FSOUND_Stream_GetOpenState.   * </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - stream to have its position returned.<DD><CODE>sentencelist</CODE> - IntBuffer describing a list of substream indicies to play back.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_SetSyncCallback(org.lwjgl.fmod3.FSoundStream, org.lwjgl.fmod3.callbacks.FSoundStreamCallback)"><!-- --></A><H3>
FSOUND_Stream_SetSyncCallback</H3>
<PRE>
public static boolean <B>FSOUND_Stream_SetSyncCallback</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                                    <A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundStreamCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundStreamCallback</A>&nbsp;callback)</PRE>
<DL>
<DD>Sets a callback function for when a stream passes over a WAV tag/marker. These are markers that
 a sound editing program such as Sound Forge can drop into the actual wave data. FMOD will
 trigger callbacks with these markers when the stream plays, and pass in the string through the callback that the marker contains
 <p>
 <b>Remarks</b>
 Note it uses a FSOUND_STREAMCALLBACK function callback. This is normally for user streams but for 
 the sake of re-usability this prototype is used. 'buff' is a null terminated string provided by 
 the marker. 'len' is the offset in samples that the marker was set at.
 The return value can be TRUE or FALSE, it is ignored.
 -----------
 Note you can save a WAV out using an MP3 wav codec (and then just rename the WAV to MP3 if you like) to get 
 sync marker support for compressed MP3 files. FMOD will pick up on this and read the markers out.
 --------------
 If the stream has been opened with FSOUND_NONBLOCKING, this function will not succeed until the stream is ready.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - to set the SyncCallback callback for<DD><CODE>callback</CODE> - FSoundStreamCallback callback to attach to this stream
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Stream_SetTime(org.lwjgl.fmod3.FSoundStream, int)"><!-- --></A><H3>
FSOUND_Stream_SetTime</H3>
<PRE>
public static int <B>FSOUND_Stream_SetTime</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundStream.html" title="class in org.lwjgl.fmod3">FSoundStream</A>&nbsp;stream,
                                        int&nbsp;ms)</PRE>
<DL>
<DD>Sets the current stream's FILE position in MILLISECONDS
 <p>
 <b>Remarks</b>
 If the stream has been opened with FSOUND_NONBLOCKING, this function will not succeed until the stream is ready.
 FSOUND_MPEGACCURATE will need to be used with mp3 files that use VBR encoding for more accuracy.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>stream</CODE> - to have its position set<DD><CODE>ms</CODE> - Time in milliseconds to seek to.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_CD_OpenTray(char, boolean)"><!-- --></A><H3>
FSOUND_CD_OpenTray</H3>
<PRE>
public static boolean <B>FSOUND_CD_OpenTray</B>(char&nbsp;drive,
                                         boolean&nbsp;open)</PRE>
<DL>
<DD>Opens/Closes the CD tray
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>drive</CODE> - The drive ID to use. 0 is the default CD drive. Using D or E in single quotes would be D: or E: for example.<DD><CODE>open</CODE> - If open is set to true, the CD tray will be opened. If open is set to false, the CD tray will be closed.
<DT><B>Returns:</B><DD>On success, true is is returned. On failure, false is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_CD_GetNumTracks(char)"><!-- --></A><H3>
FSOUND_CD_GetNumTracks</H3>
<PRE>
public static int <B>FSOUND_CD_GetNumTracks</B>(char&nbsp;drive)</PRE>
<DL>
<DD>Returns the number of tracks on the currently inserted CD
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>drive</CODE> - the drive ID to use. 0 is the default CD drive. Using D or E in single quotes would be D: or E: for example.
<DT><B>Returns:</B><DD>On success, the number of CD tracks on the currently inserted is returned. On failure, 0 is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_CD_GetPaused(char)"><!-- --></A><H3>
FSOUND_CD_GetPaused</H3>
<PRE>
public static boolean <B>FSOUND_CD_GetPaused</B>(char&nbsp;drive)</PRE>
<DL>
<DD>Gets the pause status of the current CD audio track
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>drive</CODE> - the drive ID to use. 0 is the default CD drive. Using D or E in single quotes would be D: or E: for example.
<DT><B>Returns:</B><DD>If the track is currently paused, TRUE is returned. if the track is currently not paused, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_CD_GetTrack(char)"><!-- --></A><H3>
FSOUND_CD_GetTrack</H3>
<PRE>
public static int <B>FSOUND_CD_GetTrack</B>(char&nbsp;drive)</PRE>
<DL>
<DD>Returns the currently playing CD track number
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>drive</CODE> - the drive ID to use. 0 is the default CD drive. Using D or E in single quotes would be D: or E: for example.
<DT><B>Returns:</B><DD>On success, the CD track number currently playing is returned. (starts from 1) On failure, 0 is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_CD_GetTrackLength(char, int)"><!-- --></A><H3>
FSOUND_CD_GetTrackLength</H3>
<PRE>
public static int <B>FSOUND_CD_GetTrackLength</B>(char&nbsp;drive,
                                           int&nbsp;track)</PRE>
<DL>
<DD>Gets the track length of a CD
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>drive</CODE> - the drive ID to use. 0 is the default CD drive. Using D or E in single quotes would be D: or E: for example.<DD><CODE>track</CODE> - The CD track number to query the length of. (starts from 1)
<DT><B>Returns:</B><DD>On success, the length of the current track in milliseconds is returned. On failure, 0 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_CD_GetTrackTime(char)"><!-- --></A><H3>
FSOUND_CD_GetTrackTime</H3>
<PRE>
public static int <B>FSOUND_CD_GetTrackTime</B>(char&nbsp;drive)</PRE>
<DL>
<DD>Returns the current track time playing on a CD
 <p>
 <b>Remarks</b>
 This is easily one of the slowest functions in the FMOD API. Please use it sparingly. 
 It seems like it shouldnt take long, but because of windows MCI API it does, and not just a little bit of time, it takes a LOT. 
 It seems to poll the CD driver and cause a large delay upon completion of the command. 
 Different algorithms were used to try and emulate this function such as simply using a timer, but this was very inaccurate, especially when pausing/unpausing a lot.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>drive</CODE> - the drive ID to use. 0 is the default CD drive. Using D or E in single quotes would be D: or E: for example.
<DT><B>Returns:</B><DD>On success, the position of the current playing track in milliseconds is returned. On failure, 0 is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_CD_Play(char, int)"><!-- --></A><H3>
FSOUND_CD_Play</H3>
<PRE>
public static boolean <B>FSOUND_CD_Play</B>(char&nbsp;drive,
                                     int&nbsp;track)</PRE>
<DL>
<DD>Plays a CD Audio track
 <p>
 <b>Remarks</b>
 See FSOUND_CD_SetPlayMode for information on how to control playback of a CD track.
 FSOUND's CD Playback system, is a non intrusive, non polling system. 
 This may not mean much to a lot of people, but a polling player (take the windows default CD player) will consistantly poll the CD device to update its status, which causes other applications to jerk, or pause consistantly. 
 This would be inexcusable in a game, to have the game halt or jerk every second to few seconds or so. 
 FSOUND uses timing and prediction to loop tracks and update the status of the CD, and never touches the CD device during playback, for TRUE 0% cpu usage.   
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>drive</CODE> - the drive ID to use. 0 is the default CD drive. Using D or E in single quotes would be D: or E: for example.<DD><CODE>track</CODE> - The CD track number to query the length of. (starts from 1)
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_CD_SetPaused(char, boolean)"><!-- --></A><H3>
FSOUND_CD_SetPaused</H3>
<PRE>
public static boolean <B>FSOUND_CD_SetPaused</B>(char&nbsp;drive,
                                          boolean&nbsp;paused)</PRE>
<DL>
<DD>Sets the pause status of the currently playing CD audio track
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>drive</CODE> - the drive ID to use. 0 is the default CD drive. Using D or E in single quotes would be D: or E: for example.<DD><CODE>paused</CODE> - TRUE to pause track, FALSE to unpause track
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_CD_SetPlayMode(char, int)"><!-- --></A><H3>
FSOUND_CD_SetPlayMode</H3>
<PRE>
public static void <B>FSOUND_CD_SetPlayMode</B>(char&nbsp;drive,
                                         int&nbsp;mode)</PRE>
<DL>
<DD>Sets the playback mode of the CD
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>drive</CODE> - the drive ID to use. 0 is the default CD drive. Using D or E in single quotes would be D: or E: for example.<DD><CODE>mode</CODE> - See FSOUND_CDPLAYMODES for a list of valid parameters to send to this function</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_CD_SetTrackTime(char, int)"><!-- --></A><H3>
FSOUND_CD_SetTrackTime</H3>
<PRE>
public static boolean <B>FSOUND_CD_SetTrackTime</B>(char&nbsp;drive,
                                             int&nbsp;ms)</PRE>
<DL>
<DD>Performs a seek within a track specified by milliseconds
 <p>
 <b>Remarks</b>
 This function will start the track if it is not playing
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>drive</CODE> - the drive ID to use. 0 is the default CD drive. Using D or E in single quotes would be D: or E: for example.<DD><CODE>ms</CODE> - Time to seek into the current track in milliseconds
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_CD_SetVolume(char, int)"><!-- --></A><H3>
FSOUND_CD_SetVolume</H3>
<PRE>
public static boolean <B>FSOUND_CD_SetVolume</B>(char&nbsp;drive,
                                          int&nbsp;volume)</PRE>
<DL>
<DD>Sets the volume of the playing CD audio
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>drive</CODE> - the drive ID to use. 0 is the default CD drive. Using D or E in single quotes would be D: or E: for example.<DD><CODE>volume</CODE> - An integer value from 0-255. 0 being the lowest volume, 255 being the highest (full).
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_CD_Stop(char)"><!-- --></A><H3>
FSOUND_CD_Stop</H3>
<PRE>
public static boolean <B>FSOUND_CD_Stop</B>(char&nbsp;drive)</PRE>
<DL>
<DD>Stops the currently playing CD audio track
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>drive</CODE> - the drive ID to use. 0 is the default CD drive. Using D or E in single quotes would be D: or E: for example.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_DSP_ClearMixBuffer()"><!-- --></A><H3>
FSOUND_DSP_ClearMixBuffer</H3>
<PRE>
public static void <B>FSOUND_DSP_ClearMixBuffer</B>()</PRE>
<DL>
<DD>Clears the mixbuffer, especially handy if you are doing a large file operation which 
 halts the system. 
 You might try and stop all the sounds, but if you do your file operation straight after
 this, it will not have a chance to flush the mixbuffer normally, so this function is called.
 It stops the effect of stuttering looping sound while your file operation happens.
 <p>
 <b>Remarks</b>
 The best way to do it is like this. Turn off the sfx and music DSP units, clear the mix buffer,
 then when the operation that halts the machine is done, just re-enable the sfx and music DSP units.
 Disabling these units stops the timer trying to get 1 or 2 more mixes in during the file operation,
 which will cause more stuttering.
 ie.
 FSOUND_DSP_SetActive(FSOUND_DSP_GetSFXUnit(), FALSE);
 FSOUND_DSP_SetActive(FSOUND_DSP_GetMusicUnit(), FALSE);
 FSOUND_DSP_ClearMixBuffer();
 //
 // maching halting operation here
 //
 FSOUND_DSP_SetActive(FSOUND_DSP_GetSFXUnit(), TRUE);
 FSOUND_DSP_SetActive(FSOUND_DSP_GetMusicUnit(), TRUE);
 </p>
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_DSP_Create(org.lwjgl.fmod3.callbacks.FSoundDSPCallback, int)"><!-- --></A><H3>
FSOUND_DSP_Create</H3>
<PRE>
public static <A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A> <B>FSOUND_DSP_Create</B>(<A HREF="../../../org/lwjgl/fmod3/callbacks/FSoundDSPCallback.html" title="interface in org.lwjgl.fmod3.callbacks">FSoundDSPCallback</A>&nbsp;callbackHandler,
                                              int&nbsp;priority)</PRE>
<DL>
<DD>Creates a DSP unit, and places it in the DSP chain position specified by the priority
 parameter. Read the remarks section carefully for issues regarding DSP units.
 DSP units are freed with FSOUND_DSP_Free
 <p>
 <b>Remarks</b>
 A dsp unit is NOT ACTIVE by default. You have to activate it with FSOUND_DSP_SetActive
 ---------------------------------------------------------------------------------------
 Priorities and default system units.
 ---------------------------------------------------------------------------------------
 A note on priorities. FSOUND processes DSP units in order of priority. A 0 priority
 unit gets processed first, a 1 priority unit gets processed next, and so on. 
 FSOUND actually uses these DSP units to mix its sound effects and music! Yes, you have
 access to them (be careful!). It is possible to totally remove, replace or deactivate 
 all of FSOUND's system units so that it does nothing at all!
 FSOUND has preinstalled default system units at the following priority locations:
 FSOUND_DSP_DEFAULTPRIORITY_CLEARUNIT (priority 0) - Clear Unit. This unit clears out 
 the mixbuffer for the next units to mix into. You can disable this unit and replace
 it with something other than a clearer, such as a scaler, which fades down the mix
 buffer instead of clearing it, to produce a very rough echo effect.
 FSOUND_DSP_DEFAULTPRIORITY_SFXUNIT (priority 100) - SFX Unit. This unit mixes sound 
 effect channels into the mix buffer, which was previously cleared with the Clear 
 Unit. 
 FSOUND_DSP_DEFAULTPRIORITY_MUSICUNIT (priority 200) - Music Unit. This unit mixes all 
 music channels into the mix buffer, which was previously mixed into with the SFX 
 Unit. 
 FSOUND_DSP_DEFAULTPRIORITY_CLIPANDCOPYUNIT (priority 1000) - Clip and Copy Unit. This 
 unit takes the finally mixed buffer, and clips it to the output stream size (if it
 needs to), and then sends it off to the sound device. It is done last. If this is
 disabled you will hear no sound.
 ---------------------------------------------------------------------------------------
 Buffer Lengths.
 ---------------------------------------------------------------------------------------
 The 'length' value of the DSP callback is roughly 20ms worth of data.
 Use FSOUND_DSP_GetBufferLength to get the exact callback length.
 ---------------------------------------------------------------------------------------
 Buffer Widths
 ---------------------------------------------------------------------------------------
 Remember that FSOUND uses different buffer types depending on what type of mixer it is.
 You will have to compensate for this by writing different routines depending on the 
 mixer type (ie mmx or non mmx), just like FSOUND does. 
 Currently there are the 3 types of mixers and their buffer sizes.
 You can get the type of mixer being used by calling the FSOUND_GetMixer function.
 You may want to check on this inside your callback, or set up a function pointer system,
 whatever you think is suitable (it costs nothing to do a FSOUND_GetMixer every time).
 - FSOUND_MIXER_BLENDMODE : This buffer is a stereo, signed 32bit buffer (8 bytes per 
 sample). The data is in integer format.
 Data written to this buffer is not clipped and passed to the output stream until the 
 very end of the chain (the clip and copy unit). For this type of mixer, you dont 
 have to worry about clipping becuase FSOUND does this for you.
 - FSOUND_MIXER_QUALITY_FPU / FSOUND_MIXER_QUALITY_FPU_VOLUMERAMP: This buffer is also a 
 stereo, signed 32bit buffer (8 bytes per sample). This data is in floating point 
 format.
 The same clip and copy rules apply here as for the above mixer.
 - Any MMX based mixer : This buffer is a stereo, signed 16bit buffer (4 bytes per sample).
 When writing to this buffer, you must make sure the result does not overflow this 
 signed 16bit range.
 If you add data into to this buffer, make sure it is clipped to a signed 16bit range
 before writing it back. FSOUND only copies this data to the output stream, it does
 not clip it.
 ---------------------------------------------------------------------------------------
 Speed
 ---------------------------------------------------------------------------------------
 DSP Units are processed then and there, inside the mixing routine. Remember to make
 your process as FAST as possible, or the output device's play cursor will catch up to
 FSOUND's write cursor while your routine takes its time to complete, and make it start 
 to break up. 
 So basically, if it isnt fast, then FSOUND will not be able to send the data to the
 output device in time for the next mixer update, and the result will be corrupted sound.
 FSOUND_DSP_MixBuffers is available now, so if you need to mix some raw data into the output 
 buffer quickly, you can use FSOUND's own optimized mixer directly to do it!
 Finally, you can see how your routine affects cpu usage, by using FSOUND_GetCPUUsage.
 The cpu usage returned by this function includes any time spent in DSP units as well.
 (this function times everything). If you are really bored, you can see how much FSOUND's
 system units take cpu-wise, by turning them on and off and seeing how they affect 
 performance.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>callbackHandler</CODE> - This is a reference to your DSP Unit callback, of type FSOUND_DSPCALLBACK.
 The prototype for a callback is declared in the following fashion.
 Callbacks must return a pointer to the buffer you work on, so that
 the next dsp unit can work on it. 
 See the definition of FSOUND_DSPCALLBACK for more.<DD><CODE>priority</CODE> - Order in the priority chain. Valid numbers are 0 to 1000, 0 being
 highest priority (first), with 1000 being lowest priority (last).
 Note that FSOUNDs soundeffects mixers and copy routines are considered
 part of this DSP unit chain which you can play with.
<DT><B>Returns:</B><DD>On success, a new valid DSP unit is returned. On failure, NULL is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_DSP_Free(org.lwjgl.fmod3.FSoundDSPUnit)"><!-- --></A><H3>
FSOUND_DSP_Free</H3>
<PRE>
public static void <B>FSOUND_DSP_Free</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A>&nbsp;unit)</PRE>
<DL>
<DD>Frees and removes a DSP unit from the DSP chain
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>unit</CODE> - DSP unit to be freed</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_DSP_SetActive(org.lwjgl.fmod3.FSoundDSPUnit, boolean)"><!-- --></A><H3>
FSOUND_DSP_SetActive</H3>
<PRE>
public static void <B>FSOUND_DSP_SetActive</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A>&nbsp;unit,
                                        boolean&nbsp;active)</PRE>
<DL>
<DD>Allows the user to toggle a DSP unit on or off
 <p>
 <b>Remarks</b>
 It is possible to toggle on and off FSOUNDs internal DSP units, though not recommended
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>unit</CODE> - DSP unit to have its active flag changed<DD><CODE>active</CODE> - Flag to say whether DSP unit should be rendered active or inactive. valid values are TRUE or FALSE</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_DSP_GetActive(org.lwjgl.fmod3.FSoundDSPUnit)"><!-- --></A><H3>
FSOUND_DSP_GetActive</H3>
<PRE>
public static boolean <B>FSOUND_DSP_GetActive</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A>&nbsp;unit)</PRE>
<DL>
<DD>Returns if a DSP unit is active or not
 <p>
 <b>Remarks</b>
 It is possible to toggle on and off FSOUNDs internal DSP units, though not recommended
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>unit</CODE> - DSP unit to have its active flag returned
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_DSP_GetBufferLength()"><!-- --></A><H3>
FSOUND_DSP_GetBufferLength</H3>
<PRE>
public static int <B>FSOUND_DSP_GetBufferLength</B>()</PRE>
<DL>
<DD>Returns the buffer lenth passed by the DSP system to DSP unit callbacks, so you can allocate memory etc 
 using this data
 <p>
 <b>Remarks</b>
 Remember this is samples not bytes. To convert to bytes you 
 will have to multiply by 4 for mmx mixers, 8 for other mixers.
 (a stereo 16bit sample = 4 bytes, and a stereo 32bit sample (ie fpu) = 8 bytes)
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The size of the DSP unit buffer in SAMPLES (not bytes)</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_DSP_GetBufferLengthTotal()"><!-- --></A><H3>
FSOUND_DSP_GetBufferLengthTotal</H3>
<PRE>
public static int <B>FSOUND_DSP_GetBufferLengthTotal</B>()</PRE>
<DL>
<DD>This is the total size in samples (not bytes) of the FSOUND mix buffer. This is affected
 by FSOUND_SetBufferSize.
 <p>
 <b>Remarks</b>
 Remember this is samples not bytes. To convert to bytes you 
 will have to multiply by 4 for mmx mixers, 8 for other mixers.
 (a stereo 16bit sample = 4 bytes, and a stereo 32bit sample (ie fpu) = 8 bytes)
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The size of the FSOUND mixing buffer in SAMPLES (not bytes).</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_DSP_SetPriority(org.lwjgl.fmod3.FSoundDSPUnit, int)"><!-- --></A><H3>
FSOUND_DSP_SetPriority</H3>
<PRE>
public static void <B>FSOUND_DSP_SetPriority</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A>&nbsp;unit,
                                          int&nbsp;priority)</PRE>
<DL>
<DD>Changes a DSP Unit's priority position in the DSP chain
 <p>
 <b>Remarks</b>
 DSP units with the same priority as a previous unit already in the chain will be placed
 AFTER all like priority units
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>unit</CODE> - DSP unit to have its priority changed<DD><CODE>priority</CODE> - Order in the priority chain. Valid numbers are 0 to 1000, 0 being highest priority (first), with 1000 being lowest priority (last).</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_DSP_GetPriority(org.lwjgl.fmod3.FSoundDSPUnit)"><!-- --></A><H3>
FSOUND_DSP_GetPriority</H3>
<PRE>
public static int <B>FSOUND_DSP_GetPriority</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A>&nbsp;unit)</PRE>
<DL>
<DD>Returns the priority status in the DSP chain, of a specified unit.
 <p>
 <b>Remarks</b>
 DSP units with the same priority as a previous unit already in the chain will be placed
 AFTER all like priority units
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>unit</CODE> - DSP unit to get priority value from
<DT><B>Returns:</B><DD>On success, the priority of the unit, from 0 to 1000. On failure, -1 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_DSP_GetClearUnit()"><!-- --></A><H3>
FSOUND_DSP_GetClearUnit</H3>
<PRE>
public static <A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A> <B>FSOUND_DSP_GetClearUnit</B>()</PRE>
<DL>
<DD>Returns a reference to FSOUND's system DSP clear unit
 <p>
 <b>Remarks</b>
 The FSOUND clear DSP unit simply sets the mix buffer to 0, silencing it
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>reference to the DSP unit</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_DSP_GetClipAndCopyUnit()"><!-- --></A><H3>
FSOUND_DSP_GetClipAndCopyUnit</H3>
<PRE>
public static <A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A> <B>FSOUND_DSP_GetClipAndCopyUnit</B>()</PRE>
<DL>
<DD>Returns a reference to FSOUND's system Clip and Copy DSP unit
 <p>
 <b>Remarks</b>
 The FSOUND ClipAndCopy DSP unit clips the 32bit buffer down to fit the soundcard's 16bit stereo output, and sends it off to the hardware.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>reference to the DSP unit</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_DSP_GetMusicUnit()"><!-- --></A><H3>
FSOUND_DSP_GetMusicUnit</H3>
<PRE>
public static <A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A> <B>FSOUND_DSP_GetMusicUnit</B>()</PRE>
<DL>
<DD>Returns a reference to FSOUND's system DSP Music mixer unit
 <p>
 <b>Remarks</b>
 The FSOUND Music DSP executes the FMUSIC engine and mixes the sounds spawned by the music player
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>reference to the DSP unit</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_DSP_GetSFXUnit()"><!-- --></A><H3>
FSOUND_DSP_GetSFXUnit</H3>
<PRE>
public static <A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A> <B>FSOUND_DSP_GetSFXUnit</B>()</PRE>
<DL>
<DD>Returns a reference to FSOUND's system DSP SFX mixer unit
 <p>
 <b>Remarks</b>
 The FSOUND SFX DSP unit mixes sound effects together spawned by the user
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>reference to the DSP unit</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_DSP_GetFFTUnit()"><!-- --></A><H3>
FSOUND_DSP_GetFFTUnit</H3>
<PRE>
public static <A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3">FSoundDSPUnit</A> <B>FSOUND_DSP_GetFFTUnit</B>()</PRE>
<DL>
<DD>Returns a reference to FSOUND's system DSP FFT processing unit
 <p>
 <b>Remarks</b>
 The FSOUND FFT DSP executes the FFT engine to allow FSOUND_DSP_GetSpectrum to be used.
 The FFT unit is off by default, due to the cpu expense incurred in running. Turn it on to use FSOUND_DSP_GetSpectrum
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>reference to the DSP unit</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_DSP_GetSpectrum()"><!-- --></A><H3>
FSOUND_DSP_GetSpectrum</H3>
<PRE>
public static java.nio.FloatBuffer <B>FSOUND_DSP_GetSpectrum</B>()</PRE>
<DL>
<DD>Function to return a FloatBuffer to the current spectrum buffer. The buffer contains 512 floating
  point values that represent each frequency band's amplitude for the current FMOD SoundSystem
 mixing buffer. The range of frequencies covered by the spectrum is 1 to the nyquist frequency
 or half of the output rate. So if the output rate is 44100, then frequencies provided are up
 to 22050. (entry 511)
 <p>
 <b>Remarks</b>
 Note that hardware sounds, MIDI, files do not register on the spectrum graph as they are not run through FMODs DSP system.
 Note that to use this you have to turn on the FSOUND FFT DSP unit. This is achieved by calling FSOUND_DSP_GetFFTUnit, then using FSOUND_DSP_SetActive to turn it on.
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>FloatBuffer containing 512 floats</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_DSP_MixBuffers(java.nio.ByteBuffer, java.nio.ByteBuffer, int, int, int, int, int)"><!-- --></A><H3>
FSOUND_DSP_MixBuffers</H3>
<PRE>
public static boolean <B>FSOUND_DSP_MixBuffers</B>(java.nio.ByteBuffer&nbsp;destbuffer,
                                            java.nio.ByteBuffer&nbsp;srcbuffer,
                                            int&nbsp;len,
                                            int&nbsp;freq,
                                            int&nbsp;vol,
                                            int&nbsp;pan,
                                            int&nbsp;mode)</PRE>
<DL>
<DD>Allows the user to mix their own data from one buffer to another, using FSOUNDs optimized
 mixer routines. This was mainly provided for DSP routines, though it can be used for 
 anything.
 <p>
 <b>Remarks</b>
 'destbuffer' should always the format of the mixing output buffer, as it will use the mixer
 currently running to do the mixing.
 For MMX it is 16bit stereo, so it is 4 bytes per output sample (word left, word right)
 For Standard Blend mode it is 32bit stereo, so it is 8 bytes per output sample (left dword, right dword)
 For FPU mixer it is 32bit float stereo, so it is 8 bytes per output sample (left float, right float)
 FSOUND_GetMixer can be used to determine which mixer is being used.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>destbuffer</CODE> - Pointer to a buffer to have the data mixed into.<DD><CODE>srcbuffer</CODE> - Pointer to the source buffer to be mixed in.<DD><CODE>len</CODE> - Amount to mix in SAMPLES.<DD><CODE>freq</CODE> - Speed to mix data to output buffer. Remember if you mix at a rate
 different than the output rate, the buffer lengths will have to be
 different to compensate. Ie if the output rate is 44100 and you supply
 a value of 88200 to FSOUND_DSP_MixBuffers, you will only need a destbuffer
 that is half the size of srcbuffer. If you supply a value of 22050 then
 you will need a destbuffer that is twice as big as srcbuffer. If they
 are both the same size then it will only mix half of the data.<DD><CODE>vol</CODE> - volume scalar value of mix. Valid values are 0 (silence) to 255
 (full volume). See FSOUND_SetVolume for more information.<DD><CODE>pan</CODE> - pan value for data being mixed. Valid values are 0 (full left), 128
 (middle), 255 (full right) and FSOUND_STEREOPAN. See FSOUND_SetPan for
 more information.<DD><CODE>mode</CODE> - Bit settings to describe the source buffer. Valid values are found in
 FSOUND_MODES, but only 8/16bit and stereo/mono flags are interpreted, other flags are ignored.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_FX_Disable(int)"><!-- --></A><H3>
FSOUND_FX_Disable</H3>
<PRE>
public static boolean <B>FSOUND_FX_Disable</B>(int&nbsp;channel)</PRE>
<DL>
<DD>Disables effect processing for ALL effects on the specified channel
 <p>
 <b>Remarks</b>
 FSOUND_ALL is supported. Passing this will disable fx on ALL channels available.
 This command can only be issued while the channel is paused or stopped.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - Channel number/handle to disable all fx for
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_FX_Enable(int, int)"><!-- --></A><H3>
FSOUND_FX_Enable</H3>
<PRE>
public static int <B>FSOUND_FX_Enable</B>(int&nbsp;channel,
                                   int&nbsp;fxtype)</PRE>
<DL>
<DD>Enables effect processing for the specified channel. This command continues to add effects to a channel (up to 16) until FSOUND_FX_Disable is called.
 <p>
 <b>Remarks</b>
 FSOUND_ALL is supported. Passing this will enable fx on ALL channels available.
 This command can only be issued while the channel is paused.
 If an effect is not enabled, then it will not be affected by its corresponding FSOUND_FX_Set functions.
 This function must be played after a paused PlaySoundEx (ie FSOUND_PlaySoundEx(FSOUND_FREE, sound, NULL, TRUE)), and before
 the FSOUND_SetPaused(FALSE) so that the hardware can get the resource before it starts playing.
 A total of 16 FX per channel is allowed, any more will result in an error. FX are reset to 0 after a sound is stopped or played. (but as above, before the unpausing of a play-paused sound).
 Warning : This function is expensive to call as it has to set up fx buffers etc. It is best to call it once, reserve the channel then reuse the channel index when calling playsound without calling it again.
 Note : Channels with FX enabled sounds cannot have their frequency changed.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - Channel number/handle to disable all fx for<DD><CODE>fxtype</CODE> - A single fx enum value to enable certain effects.
<DT><B>Returns:</B><DD>On success, an FX id is returned. On failure, -1 is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_FX_SetChorus(int, float, float, float, float, int, float, int)"><!-- --></A><H3>
FSOUND_FX_SetChorus</H3>
<PRE>
public static boolean <B>FSOUND_FX_SetChorus</B>(int&nbsp;fxid,
                                          float&nbsp;WetDryMix,
                                          float&nbsp;Depth,
                                          float&nbsp;Feedback,
                                          float&nbsp;Frequency,
                                          int&nbsp;Waveform,
                                          float&nbsp;Delay,
                                          int&nbsp;Phase)</PRE>
<DL>
<DD>Sets the parameters for the chorus effect on a particular channel
 <p>
 <b>Remarks</b>
 Make sure you have enabled this effect with FSOUND_FX_CHORUS before using this function.   
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fxid</CODE> - fx handle generated by FSOUND_FX_Enable, to set chorus parameters for.<DD><CODE>WetDryMix</CODE> - Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 through 100 (all wet).<DD><CODE>Depth</CODE> - Percentage by which the delay time is modulated by the low-frequency oscillator, in hundredths of a percentage point. Must be in the range from 0 through 100. The default value is 25.<DD><CODE>Feedback</CODE> - Percentage of output signal to feed back into the effects input, in the range from -99 to 99. The default value is 0.<DD><CODE>Frequency</CODE> - Frequency of the LFO, in the range from 0 to 10. The default value is 0.<DD><CODE>Waveform</CODE> - Waveform of the LFO. Defined values are 0 triangle. 1 sine. By default, the waveform is a sine.<DD><CODE>Delay</CODE> - Number of milliseconds the input is delayed before it is played back, in the range from 0 to 20. The default value is 0 ms.<DD><CODE>Phase</CODE> - Phase differential between left and right LFOs, in the range from 0 through 4. Possible values are defined as follows: 
 0 -180 degrees
 1 - 90 degrees
 2 0 degrees
 3 90 degrees
 4 180 degrees
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_FX_SetCompressor(int, float, float, float, float, float, float)"><!-- --></A><H3>
FSOUND_FX_SetCompressor</H3>
<PRE>
public static boolean <B>FSOUND_FX_SetCompressor</B>(int&nbsp;fxid,
                                              float&nbsp;Gain,
                                              float&nbsp;Attack,
                                              float&nbsp;Release,
                                              float&nbsp;Threshold,
                                              float&nbsp;Ratio,
                                              float&nbsp;Predelay)</PRE>
<DL>
<DD>Sets the parameters for the compressor effect on a particular channel
 <p>
 <b>Remarks</b>
 Make sure you have enabled this effect with FSOUND_FX_COMPRESSOR before using this function   
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fxid</CODE> - fx handle generated by FSOUND_FX_Enable, to set compressor parameters for.<DD><CODE>Gain</CODE> - Output gain of signal after compression, in the range from -60 to 60. The default value is 0 dB.<DD><CODE>Attack</CODE> - Time before compression reaches its full value, in the range from 0.01 to 500. The default value is 0.01 ms.<DD><CODE>Release</CODE> - Speed at which compression is stopped after input drops below fThreshold, in the range from 50 to 3000. The default value is 50 ms.<DD><CODE>Threshold</CODE> - Point at which compression begins, in decibels, in the range from -60 to 0. The default value is -10 dB.<DD><CODE>Ratio</CODE> - Compression ratio, in the range from 1 to 100. The default value is 10, which means 10:1 compression.<DD><CODE>Predelay</CODE> - Time after lThreshold is reached before attack phase is started, in milliseconds, in the range from 0 to 4. The default value is 0 ms.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_FX_SetDistortion(int, float, float, float, float, float)"><!-- --></A><H3>
FSOUND_FX_SetDistortion</H3>
<PRE>
public static boolean <B>FSOUND_FX_SetDistortion</B>(int&nbsp;fxid,
                                              float&nbsp;Gain,
                                              float&nbsp;Edge,
                                              float&nbsp;PostEQCenterFrequency,
                                              float&nbsp;PostEQBandwidth,
                                              float&nbsp;PreLowpassCutoff)</PRE>
<DL>
<DD>Sets the parameters for the distortion effect on a particular channel
 <p>
 <b>Remarks</b>
 Make sure you have enabled this effect with FSOUND_FX_DISTORTION before using this function   
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fxid</CODE> - fx handle generated by FSOUND_FX_Enable, to set distortion parameters for.<DD><CODE>Gain</CODE> - Amount of signal change after distortion, in the range from -60 through 0. The default value is 0 dB.<DD><CODE>Edge</CODE> - Percentage of distortion intensity, in the range in the range from 0 through 100. The default value is 50 percent.<DD><CODE>PostEQCenterFrequency</CODE> - Center frequency of harmonic content addition, in the range from 100 through 8000. The default value is 4000 Hz.<DD><CODE>PostEQBandwidth</CODE> - Width of frequency band that determines range of harmonic content addition, in the range from 100 through 8000. The default value is 4000 Hz.<DD><CODE>PreLowpassCutoff</CODE> - Filter cutoff for high-frequency harmonics attenuation, in the range from 100 through 8000. The default value is 4000 Hz.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_FX_SetEcho(int, float, float, float, float, int)"><!-- --></A><H3>
FSOUND_FX_SetEcho</H3>
<PRE>
public static boolean <B>FSOUND_FX_SetEcho</B>(int&nbsp;fxid,
                                        float&nbsp;WetDryMix,
                                        float&nbsp;Feedback,
                                        float&nbsp;LeftDelay,
                                        float&nbsp;RightDelay,
                                        int&nbsp;PanDelay)</PRE>
<DL>
<DD>Sets the parameters for the echo effect on a particular channel
 <p>
 <b>Remarks</b>
 Make sure you have enabled this effect with FSOUND_FX_Enable and FSOUND_FX_ECHO before using this function.   
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fxid</CODE> - fx handle generated by FSOUND_FX_Enable, to set echo parameters for.<DD><CODE>WetDryMix</CODE> - Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 through 100 (all wet).<DD><CODE>Feedback</CODE> - Percentage of output fed back into input, in the range from 0 through 100. The default value is 0.<DD><CODE>LeftDelay</CODE> - Delay for left channel, in milliseconds, in the range from 1 through 2000. The default value is 333 ms.<DD><CODE>RightDelay</CODE> - Delay for right channel, in milliseconds, in the range from 1 through 2000. The default value is 333 ms.<DD><CODE>PanDelay</CODE> - Value that specifies whether to swap left and right delays with each successive echo. The default value is FALSE, meaning no swap. Possible values are defined as TRUE or FALSE.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_FX_SetFlanger(int, float, float, float, float, int, float, int)"><!-- --></A><H3>
FSOUND_FX_SetFlanger</H3>
<PRE>
public static boolean <B>FSOUND_FX_SetFlanger</B>(int&nbsp;fxid,
                                           float&nbsp;WetDryMix,
                                           float&nbsp;Depth,
                                           float&nbsp;Feedback,
                                           float&nbsp;Frequency,
                                           int&nbsp;Waveform,
                                           float&nbsp;Delay,
                                           int&nbsp;Phase)</PRE>
<DL>
<DD>Sets the parameters for the echo effect on a particular channel
 <p>
 <b>Remarks</b>
 Make sure you have enabled this effect with FSOUND_FX_Enable and FSOUND_FX_FLANGER before using this function.   
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fxid</CODE> - fx handle generated by FSOUND_FX_Enable, to set flanger parameters for.<DD><CODE>WetDryMix</CODE> - Ratio of wet (processed) signal to dry (unprocessed) signal. Must be in the range from 0 through 100 (all wet).<DD><CODE>Depth</CODE> - Percentage by which the delay time is modulated by the low-frequency oscillator (LFO), in hundredths of a percentage point. Must be in the range from 0 through 100. The default value is 25.<DD><CODE>Feedback</CODE> - Percentage of output signal to feed back into the effects input, in the range from -99 to 99. The default value is 0.<DD><CODE>Frequency</CODE> - Frequency of the LFO, in the range from 0 to 10. The default value is 0.<DD><CODE>Waveform</CODE> - Waveform of the LFO. By default, the waveform is a sine. Possible values are defined as follows: 
 0 - Triangle. 
 1 - Sine.<DD><CODE>Delay</CODE> - Number of milliseconds the input is delayed before it is played back, in the range from 0 to 4. The default value is 0 ms.<DD><CODE>Phase</CODE> - Phase differential between left and right LFOs, in the range from 0 through 4. Possible values are defined as follows: 
 0 -180 degrees
 1 - 90 degrees
 2 0 degrees
 3 90 degrees
 4 180 degrees
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_FX_SetGargle(int, int, int)"><!-- --></A><H3>
FSOUND_FX_SetGargle</H3>
<PRE>
public static boolean <B>FSOUND_FX_SetGargle</B>(int&nbsp;fxid,
                                          int&nbsp;RateHz,
                                          int&nbsp;WaveShape)</PRE>
<DL>
<DD>Sets the parameters for the echo effect on a particular channel
 <p>
 <b>Remarks</b>
 Make sure you have enabled this effect with FSOUND_FX_Enable and FSOUND_FX_GARGLE before using this function.   
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fxid</CODE> - fx handle generated by FSOUND_FX_Enable, to set gargle parameters for.<DD><CODE>RateHz</CODE> - Rate of modulation, in Hertz. Must be in the range from 1 through 1000.<DD><CODE>WaveShape</CODE> - Shape of the modulation wave. The following values are defined.
 0 - Triangular wave.
 1 - Square wave.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_FX_SetI3DL2Reverb(int, int, int, float, float, float, int, float, int, float, float, float, float)"><!-- --></A><H3>
FSOUND_FX_SetI3DL2Reverb</H3>
<PRE>
public static boolean <B>FSOUND_FX_SetI3DL2Reverb</B>(int&nbsp;fxid,
                                               int&nbsp;Room,
                                               int&nbsp;RoomHF,
                                               float&nbsp;RoomRolloffFactor,
                                               float&nbsp;DecayTime,
                                               float&nbsp;DecayHFRatio,
                                               int&nbsp;Reflections,
                                               float&nbsp;ReflectionsDelay,
                                               int&nbsp;Reverb,
                                               float&nbsp;ReverbDelay,
                                               float&nbsp;Diffusion,
                                               float&nbsp;Density,
                                               float&nbsp;HFReference)</PRE>
<DL>
<DD>Sets the parameters for the I3DL2 Reverb effect on a particular channel
 <p>
 <b>Remarks</b>
 Make sure you have enabled this effect with FSOUND_FX_Enable and FSOUND_FX_I3DL2REVERB before using this function.   
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fxid</CODE> - fx handle generated by FSOUND_FX_Enable, to set I3DL2 Reverb parameters for.<DD><CODE>Room</CODE> - Attenuation of the room effect, in millibels (mB), in the range from -10000 to 0. The default value is -1000 mB.<DD><CODE>RoomHF</CODE> - Attenuation of the room high-frequency effect, in mB, in the range from -10000 to 0. The default value is 0 mB.<DD><CODE>RoomRolloffFactor</CODE> - Rolloff factor for the reflected signals, in the range from 0 to 10. The default value is 0.0. The rolloff factor for the direct path is controlled by the listener.<DD><CODE>DecayTime</CODE> - Decay time, in seconds, in the range from .1 to 20. The default value is 1.49 seconds.<DD><CODE>DecayHFRatio</CODE> - Ratio of the decay time at high frequencies to the decay time at low frequencies, in the range from 0.1 to 2. The default value is 0.83.<DD><CODE>Reflections</CODE> - Attenuation of early reflections relative to lRoom, in mB, in the range from -10000 to 1000. The default value is -2602 mB.<DD><CODE>ReflectionsDelay</CODE> - Delay time of the first reflection relative to the direct path, in seconds, in the range from 0 to 0.3. The default value is 0.007 seconds.<DD><CODE>Reverb</CODE> - Attenuation of late reverberation relative to lRoom, in mB, in the range from -10000 to 2000. The default value is 200 mB.<DD><CODE>ReverbDelay</CODE> - Time limit between the early reflections and the late reverberation relative to the time of the first reflection, in seconds, in the range from 0 to 0.1. The default value is 0.011 seconds.<DD><CODE>Diffusion</CODE> - Echo density in the late reverberation decay, in percent, in the range from 0 to 100. The default value is 100.0 percent.<DD><CODE>Density</CODE> - Modal density in the late reverberation decay, in percent, in the range from 0 to 100. The default value is 100.0 percent.<DD><CODE>HFReference</CODE> - Reference high frequency, in hertz, in the range from 20 to 20000. The default value is 5000.0 Hz.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_FX_SetParamEQ(int, float, float, float)"><!-- --></A><H3>
FSOUND_FX_SetParamEQ</H3>
<PRE>
public static boolean <B>FSOUND_FX_SetParamEQ</B>(int&nbsp;fxid,
                                           float&nbsp;Center,
                                           float&nbsp;Bandwidth,
                                           float&nbsp;Gain)</PRE>
<DL>
<DD>Sets the parameters for the I3DL2 Reverb effect on a particular channel
 <p>
 <b>Remarks</b>
 Make sure you have enabled this effect with FSOUND_FX_Enable and FSOUND_FX_PARAMEQ before using this function.   
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fxid</CODE> - fx handle generated by FSOUND_FX_Enable, to set ParamEQ parameters for.<DD><CODE>Center</CODE> - Center frequency, in hertz, in the range from 80 to 16000. This value cannot exceed one-third of the frequency of the buffer. Default is 8000.<DD><CODE>Bandwidth</CODE> - Bandwidth, in semitones, in the range from 1 to 36. Default is 12.<DD><CODE>Gain</CODE> - Gain, in the range from -15 to 15. Default is 0.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_FX_SetWavesReverb(int, float, float, float, float)"><!-- --></A><H3>
FSOUND_FX_SetWavesReverb</H3>
<PRE>
public static boolean <B>FSOUND_FX_SetWavesReverb</B>(int&nbsp;fxid,
                                               float&nbsp;InGain,
                                               float&nbsp;ReverbMix,
                                               float&nbsp;ReverbTime,
                                               float&nbsp;HighFreqRTRatio)</PRE>
<DL>
<DD>Sets the parameters for the Waves Reverb effect on a particular channel
 <p>
 <b>Remarks</b>
 Make sure you have enabled this effect with FSOUND_FX_Enable and FSOUND_WAVES_REVERB before using this function.   
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fxid</CODE> - fx handle generated by FSOUND_FX_Enable, to set ParamEQ parameters for.<DD><CODE>InGain</CODE> - Input gain of signal, in decibels (dB), in the range from -96 through 0. The default value is 0 dB.<DD><CODE>ReverbMix</CODE> - Reverb mix, in dB, in the range from -96 through 0. The default value is 0 dB.<DD><CODE>ReverbTime</CODE> - Reverb time, in milliseconds, in the range from .001 through 3000. The default value is 1000.<DD><CODE>HighFreqRTRatio</CODE> - In the range from .001 through .999. The default value is 0.001.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Record_GetDriver()"><!-- --></A><H3>
FSOUND_Record_GetDriver</H3>
<PRE>
public static int <B>FSOUND_Record_GetDriver</B>()</PRE>
<DL>
<DD>Returns the currently selected recording driver number. Drivers are enumerated when selecting a driver 
 with FSOUND_Record_SetDriver or other driver related functions such as FSOUND_Record_GetNumDrivers or 
 FSOUND_Record_GetDriverName
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Currently selected driver id</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Record_GetDriverName(int)"><!-- --></A><H3>
FSOUND_Record_GetDriverName</H3>
<PRE>
public static java.lang.String <B>FSOUND_Record_GetDriverName</B>(int&nbsp;id)</PRE>
<DL>
<DD>Returns the name of the selected recording driver. Drivers are enumerated when selecting a driver with
 FSOUND_Record_SetDriver or other driver related functions such as FSOUND_Record_GetNumDrivers or FSOUND_Record_GetDriver
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>id</CODE> - Enumerated driver ID. This must be in a valid range delimited by FSOUND_Record_GetNumDrivers,
<DT><B>Returns:</B><DD>On success, a string containing the name of the specified device is returned. 
 The number of drivers enumerated can be found with FSOUND_Record_GetNumDrivers. On failure, NULL is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Record_GetNumDrivers()"><!-- --></A><H3>
FSOUND_Record_GetNumDrivers</H3>
<PRE>
public static int <B>FSOUND_Record_GetNumDrivers</B>()</PRE>
<DL>
<DD>Returns the number of sound cards or devices enumerated for the current input type. (Direct
 Sound, WaveOut etc.)
<P>
<DD><DL>

<DT><B>Returns:</B><DD>Total number of enumerated sound devices</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Record_GetPosition()"><!-- --></A><H3>
FSOUND_Record_GetPosition</H3>
<PRE>
public static int <B>FSOUND_Record_GetPosition</B>()</PRE>
<DL>
<DD>Gets the position in the sample buffer that has been recorded to
 <p>
 <b>Remarks</b>
 Note. This is not the 'recording cursor', but rather the latest point that the input has been copied to your sample
 </p>
<P>
<DD><DL>

<DT><B>Returns:</B><DD>On success, the offset in SAMPLES, for the record buffer that the input device has just written up to is returned.
 On failure (recording device hasnt been started), -1 is returned.</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Record_SetDriver(int)"><!-- --></A><H3>
FSOUND_Record_SetDriver</H3>
<PRE>
public static boolean <B>FSOUND_Record_SetDriver</B>(int&nbsp;driverno)</PRE>
<DL>
<DD>Returns the name of the selected recording driver. Drivers are enumerated when selecting a driver with
 FSOUND_Record_SetDriver or other driver related functions such as FSOUND_Record_GetNumDrivers or FSOUND_Record_GetDriver
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>driverno</CODE> - Recording driver number to select. &gt;=0 will select the DEFAULT recording sound driver. &lt;0 Selects other valid drivers that can be listed with FSOUND_Record_GetDriverName.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Record_StartSample(org.lwjgl.fmod3.FSoundSample, boolean)"><!-- --></A><H3>
FSOUND_Record_StartSample</H3>
<PRE>
public static boolean <B>FSOUND_Record_StartSample</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundSample.html" title="class in org.lwjgl.fmod3">FSoundSample</A>&nbsp;sample,
                                                boolean&nbsp;loop)</PRE>
<DL>
<DD>Starts recording into a predefined sample using the sample's default playback rate as the recording rate
 <p>
 <b>Remarks</b>
 If you want to play back the sample at the same time is is recording, you will have to play the sound and try and keep it just behind the recording cursor.
 Under FSOUND_OUTPUT_OSS mode, it is single duplex, so playback will stop when recording is in progress! Try FSOUND_OUTPUT_ALSA for full duplex as they have better drivers in this respect.
 -------------
 The recording/playback rates are slightly innacurate and are not identical (ie 44100.0 for playback, 44100.1 for recording), so one could possibly be faster or slower than the other. In this case the recording and the playback cursor could overlap, and the output will sound corrupted. 
 To counter this you might adjust the playback frequency of the channel you are playing the record sample on while it plays, using FSOUND_GetCurrentPosition and FSOUND_Record_GetPosition as calibration points.
 In the recording sample there is an example of trying to play back sound as it records, and the mechanism to try and keep the 2 cursors a safe distance from each other is employed.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sample</CODE> - The sample to record into.<DD><CODE>loop</CODE> - TRUE or FALSE flag whether the recorder should keep recording once it has hit the end,
 and start from the start again, therefore creating a continuous recording session into that
 sample buffer. Looping the recording buffer is good for realtime processing of recorded
 information, as you can record and playback the sample at the same time.
<DT><B>Returns:</B><DD>TRUE or FALSE flag whether the recorder should keep recording once it has hit the end, 
 and start from the start again, therefore creating a continuous recording session into that 
 sample buffer. Looping the recording buffer is good for realtime processing of recorded
 information, as you can record and playback the sample at the same time</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Record_Stop()"><!-- --></A><H3>
FSOUND_Record_Stop</H3>
<PRE>
public static boolean <B>FSOUND_Record_Stop</B>()</PRE>
<DL>
<DD>Halts recording to the specified sample
<P>
<DD><DL>

<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Reverb_SetProperties(org.lwjgl.fmod3.FSoundReverbProperties)"><!-- --></A><H3>
FSOUND_Reverb_SetProperties</H3>
<PRE>
public static boolean <B>FSOUND_Reverb_SetProperties</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundReverbProperties.html" title="class in org.lwjgl.fmod3">FSoundReverbProperties</A>&nbsp;reverb)</PRE>
<DL>
<DD>Sets hardware reverb parameters for advanced tuning. 
 The best way to modify these is to set everything to use pre-defined presets given in the header, and then start modifying values
 <p>
 <b>Remarks</b>
 You must be using FSOUND_OUTPUT_DSOUND as the output mode for this to work. 
 In dsound, the reverb will only work if you have an EAX compatible soundcard such as the SBLive, and your sample/stream was created with the FSOUND_HW3D flag.
 For GameCube, use FSOUND_AUXFX_xxx api
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reverb</CODE> - reference to a FSoundReverbProperties.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Reverb_GetProperties(org.lwjgl.fmod3.FSoundReverbProperties)"><!-- --></A><H3>
FSOUND_Reverb_GetProperties</H3>
<PRE>
public static boolean <B>FSOUND_Reverb_GetProperties</B>(<A HREF="../../../org/lwjgl/fmod3/FSoundReverbProperties.html" title="class in org.lwjgl.fmod3">FSoundReverbProperties</A>&nbsp;reverb)</PRE>
<DL>
<DD>Returns the current hardware reverb environment. 
 The best way to modify these is to set everything to use pre-defined presets given in the header, and then start modifying values
 <p>
 <b>Remarks</b>
 These values are only relevant if you are in DSOUND mode with an EAX3 compatible soundcard, or XBOX and PS2
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>reverb</CODE> - reference to a FSoundReverbProperties.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Reverb_SetChannelProperties(int, org.lwjgl.fmod3.FSoundReverbChannelProperties)"><!-- --></A><H3>
FSOUND_Reverb_SetChannelProperties</H3>
<PRE>
public static boolean <B>FSOUND_Reverb_SetChannelProperties</B>(int&nbsp;channel,
                                                         <A HREF="../../../org/lwjgl/fmod3/FSoundReverbChannelProperties.html" title="class in org.lwjgl.fmod3">FSoundReverbChannelProperties</A>&nbsp;reverb)</PRE>
<DL>
<DD>Sets the channel specific reverb properties for hardware, including wet/dry mix (room size), and things like obstruction and occlusion properties
 <p>
 <b>Remarks</b>
 FSOUND_ALL is supported here. Passing this will set ALL channels to specified reverb properties.
 If FSOUND_ALL is used the last channel success flag will be returned. This return value not useful in most circumstances.
 -----------------
 Under Win32, you must be using FSOUND_OUTPUT_DSOUND as the output mode for this to work. 
 In DSound, the reverb will only work if you have an EAX compatible soundcard such as the SBLive, and your sample/stream was created with the FSOUND_HW3D flag.
 -----------------
 On PlayStation2, the 'Room' parameter is the only parameter supported. The hardware only allows 'on' or 'off', so the reverb will be off when 'Room' is -10000 and on for every other value.
 -----------------
 On XBox, it is possible to apply reverb to 2d voices using this function. By default reverb is turned off for 2d voices.
 If this 2d voice was being positioned in a 5.1 array with the xbox only function FSOUND_SetLevels, then calling this function will disable that capability in favour of enabling reverb for the 2d voice.
 It is a limitation of the xbox hardware that only one of the other of these features can be executed at one time.
 </p>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel to have its reverb properties changed. FSOUND_ALL can also be used (see remarks)<DD><CODE>reverb</CODE> - reference to a FSoundReverbChannelProperties.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<HR>

<A NAME="FSOUND_Reverb_GetChannelProperties(int, org.lwjgl.fmod3.FSoundReverbChannelProperties)"><!-- --></A><H3>
FSOUND_Reverb_GetChannelProperties</H3>
<PRE>
public static boolean <B>FSOUND_Reverb_GetChannelProperties</B>(int&nbsp;channel,
                                                         <A HREF="../../../org/lwjgl/fmod3/FSoundReverbChannelProperties.html" title="class in org.lwjgl.fmod3">FSoundReverbChannelProperties</A>&nbsp;reverb)</PRE>
<DL>
<DD>This function gets the current reverb properties for this channel
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>channel</CODE> - The channel to have its reverb mix returned<DD><CODE>reverb</CODE> - reference to a FSoundReverbChannelProperties.
<DT><B>Returns:</B><DD>On success, TRUE is returned. On failure, FALSE is returned</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/FSound.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../org/lwjgl/fmod3/FMusicModule.html" title="class in org.lwjgl.fmod3"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../org/lwjgl/fmod3/FSoundDSPUnit.html" title="class in org.lwjgl.fmod3"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?org/lwjgl/fmod3/FSound.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="FSound.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>
<i>Copyright &#169; 2002-2006 lwjgl.org. All Rights Reserved.</i>
</BODY>
</HTML>
